<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>clarity.evaluator.haspi.eb &#8212; Project name not set  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const defaultStyle = document.createElement('style');
defaultStyle.textContent = `pre.mermaid {
    /* Same as .mermaid-container > pre */
    display: block;
    width: 100%;
}

pre.mermaid > svg {
    /* Same as .mermaid-container > pre > svg */
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}
`;
document.head.appendChild(defaultStyle);

const fullscreenStyle = document.createElement('style');
fullscreenStyle.textContent = `.mermaid-container {
    display: flex;
    flex-direction: row;
    width: 100%;
}

.mermaid-container > pre {
    display: block;
    width: 100%;
}

.mermaid-container > pre > svg {
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}

.mermaid-fullscreen-btn {
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 95vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-container-fullscreen pre.mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen .mermaid svg {
    height: 100% !important;
    width: 100% !important;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}`;
document.head.appendChild(fullscreenStyle);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const load = async () => {
    await mermaid.run();

    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");

    if ("False" === "True") {
        const mermaids_to_add_zoom = -1 === -1 ? all_mermaids.length : -1;
        if(mermaids_to_add_zoom > 0) {
            var svgs = d3.selectAll("");
            if(all_mermaids.length !== mermaids_processed.length) {
                setTimeout(load, 200);
                return;
            } else if(svgs.size() !== mermaids_to_add_zoom) {
                setTimeout(load, 200);
                return;
            } else {
                svgs.each(function() {
                    var svg = d3.select(this);
                    svg.html("<g class='wrapper'>" + svg.html() + "</g>");
                    var inner = svg.select("g");
                    var zoom = d3.zoom().on("zoom", function(event) {
                        inner.attr("transform", event.transform);
                    });
                    svg.call(zoom);
                });
            }
        }
    } else if(all_mermaids.length !== mermaids_processed.length) {
        // Wait for mermaid to process all diagrams
        setTimeout(load, 200);
        return;
    }

    const darkTheme = isDarkTheme();

    // Stop here if not adding fullscreen capability
    if ("True" !== "True") return;

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-container-fullscreen${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-container-fullscreen');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    let previousScrollOffset = [window.scrollX, window.scrollY];

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = ''
        window.scrollTo({left: previousScrollOffset[0], top: previousScrollOffset[1], behavior: 'instant'});
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.style.opacity = '50%';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            previousScrollOffset = [window.scroll, window.scrollY];
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.sdisplay = 'block';

                if ("False" === "True") {
                    setTimeout(() => {
                        const g = svg.querySelector('g');
                        if (g) {
                            var svgD3 = d3.select(svg);
                            svgD3.html("<g class='wrapper'>" + svgD3.html() + "</g>");
                            var inner = svgD3.select("g");
                            var zoom = d3.zoom().on("zoom", function(event) {
                                inner.attr("transform", event.transform);
                            });
                            svgD3.call(zoom);
                        }
                    }, 100);
                }
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", load);
</script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for clarity.evaluator.haspi.eb</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for HASPI, HASQI, HAAQI EBs&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="c1"># pylint: disable=import-error</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">njit</span>  <span class="c1"># type: ignore # &lt;-- silence mypy no attribute error</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">butter</span><span class="p">,</span>
    <span class="n">cheby2</span><span class="p">,</span>
    <span class="n">convolve</span><span class="p">,</span>
    <span class="n">correlate</span><span class="p">,</span>
    <span class="n">firwin</span><span class="p">,</span>
    <span class="n">group_delay</span><span class="p">,</span>
    <span class="n">lfilter</span><span class="p">,</span>
    <span class="n">resample_poly</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">clarity.enhancer.nalr</span><span class="w"> </span><span class="kn">import</span> <span class="n">NALR</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">clarity.utils.audiogram</span><span class="w"> </span><span class="kn">import</span> <span class="n">Audiogram</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">ndarray</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ear_model">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.ear_model">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ear_model</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">reference_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">processed</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">processed_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">hearing_loss</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">itype</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">level1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">nchan</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
    <span class="n">m_delay</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that implements a cochlear model that includes the middle ear,</span>
<span class="sd">    auditory filter bank, Outer Hair Cell (OHC) dynamic-range compression,</span>
<span class="sd">    and Inner Hair Cell (IHC) attenuation.</span>

<span class="sd">    The inputs are the reference and processed signals that are to be</span>
<span class="sd">    compared. The reference is at the reference intensity (e.g. 65 dB SPL</span>
<span class="sd">    or with NAL-R amplification) and has no other processing. The processed</span>
<span class="sd">    signal is the hearing-aid output, and is assumed to have the same or</span>
<span class="sd">    greater group delay compared to the reference.</span>

<span class="sd">    The function outputs the envelopes of the signals after OHC compression</span>
<span class="sd">    and IHC loss attenuation.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (np.ndarray): reference signal: should be adjusted to 65 dB SPL</span>
<span class="sd">            (itype=0 or 1) or to 65 dB SPL plus NAL-R gain (itype=2)</span>
<span class="sd">        reference_freq (int): sampling rate for the reference signal, Hz</span>
<span class="sd">        processed (np.ndarray): processed signal (e.g. hearing-aid output) includes</span>
<span class="sd">            HA gain</span>
<span class="sd">        processed_freq (int): sampling rate for the processed signal, Hz</span>
<span class="sd">        hearing_loss (np.ndarray): audiogram giving the hearing loss in dB at 6</span>
<span class="sd">            audiometric frequencies: [250, 500, 1000, 2000, 4000, 6000] Hz</span>
<span class="sd">        itype (int): purpose for the calculation:</span>
<span class="sd">             0=intelligibility: reference is normal hearing and must not</span>
<span class="sd">               include NAL-R EQ</span>
<span class="sd">             1=quality: reference does not include NAL-R EQ</span>
<span class="sd">             2=quality: reference already has NAL-R EQ applied</span>
<span class="sd">        level1:   level calibration: signal RMS=1 corresponds to Level1 dB SPL</span>
<span class="sd">        nchan (int): auditory frequency bands</span>
<span class="sd">        m_delay (int): Compensate for the gammatone group delay.</span>
<span class="sd">        shift (float): Basal shift of the basilar membrane length</span>

<span class="sd">    Returns:</span>
<span class="sd">        reference_db (): envelope for the reference in each band</span>
<span class="sd">        reference_basilar_membrane (): BM motion for the reference in each band</span>
<span class="sd">        processed_db (): envelope for the processed signal in each band</span>
<span class="sd">        processed_basilar_membrane (): BM motion for the processed signal in each band</span>
<span class="sd">        reference_sl (): compressed RMS average reference in each band converted</span>
<span class="sd">            to dB SL</span>
<span class="sd">        processed_sl (): compressed RMS average output in each band converted to dB SL</span>
<span class="sd">        freq_sample (): sampling rate in Hz for the model outputs</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 27 October 2011.</span>
<span class="sd">    Basilar Membrane added 30 Dec 2011.</span>
<span class="sd">    Revised 19 June 2012.</span>
<span class="sd">    Remove match of reference RMS level to processed 29 August 2012.</span>
<span class="sd">    IHC adaptation added 1 October 2012.</span>
<span class="sd">    Basilar Membrane envelope converted to dB SL, 2 Oct 2012.</span>
<span class="sd">    Filterbank group delay corrected, 14 Dec 2012.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    Updated by Gerardo Roa Dabike, September 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Processing parameters</span>
    <span class="c1"># OHC and IHC parameters for the hearing loss</span>
    <span class="c1"># Auditory filter center frequencies span 80 to 8000 Hz.</span>
    <span class="n">_center_freq</span> <span class="o">=</span> <span class="n">center_frequency</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>  <span class="c1"># Center frequencies on an ERB scale</span>

    <span class="c1"># Cochlear model parameters for the processed signal</span>
    <span class="p">(</span>
        <span class="n">attn_ohc_y</span><span class="p">,</span>
        <span class="n">bandwidth_min_y</span><span class="p">,</span>
        <span class="n">low_knee_y</span><span class="p">,</span>
        <span class="n">compression_ratio_y</span><span class="p">,</span>
        <span class="n">attn_ihc_y</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">loss_parameters</span><span class="p">(</span><span class="n">hearing_loss</span><span class="p">,</span> <span class="n">_center_freq</span><span class="p">)</span>

    <span class="c1"># The cochlear model parameters for the reference are the same as for the hearing</span>
    <span class="c1"># loss if calculating quality, but are for normal hearing if calculating</span>
    <span class="c1"># intelligibility.</span>
    <span class="k">if</span> <span class="n">itype</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">hearing_loss_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hearing_loss</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hearing_loss_x</span> <span class="o">=</span> <span class="n">hearing_loss</span>
    <span class="p">[</span>
        <span class="n">attn_ohc_x</span><span class="p">,</span>
        <span class="n">bandwidth_min_x</span><span class="p">,</span>
        <span class="n">low_knee_x</span><span class="p">,</span>
        <span class="n">compression_ratio_x</span><span class="p">,</span>
        <span class="n">attn_ihc_x</span><span class="p">,</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">loss_parameters</span><span class="p">(</span><span class="n">hearing_loss_x</span><span class="p">,</span> <span class="n">_center_freq</span><span class="p">)</span>

    <span class="c1"># Compute center frequencies for the control</span>
    <span class="n">_center_freq_control</span> <span class="o">=</span> <span class="n">center_frequency</span><span class="p">(</span><span class="n">nchan</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
    <span class="c1"># Maximum BW for the control</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">bandwidth_1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">loss_parameters</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">_center_freq_control</span><span class="p">)</span>

    <span class="c1"># Input signal adjustments</span>
    <span class="c1"># Convert the signals to 24 kHz sampling rate.</span>
    <span class="c1"># Using 24 kHz guarantees that all of the cochlear filters have the same shape</span>
    <span class="c1"># independent of the incoming signal sampling rates</span>
    <span class="n">reference_24hz</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">resample_24khz</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">reference_freq</span><span class="p">)</span>
    <span class="n">processed_24hz</span><span class="p">,</span> <span class="n">freq_sample</span> <span class="o">=</span> <span class="n">resample_24khz</span><span class="p">(</span><span class="n">processed</span><span class="p">,</span> <span class="n">processed_freq</span><span class="p">)</span>

    <span class="c1"># Check file sizes</span>
    <span class="n">min_signal_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_24hz</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed_24hz</span><span class="p">))</span>
    <span class="n">reference_24hz</span> <span class="o">=</span> <span class="n">reference_24hz</span><span class="p">[:</span><span class="n">min_signal_length</span><span class="p">]</span>
    <span class="n">processed_24hz</span> <span class="o">=</span> <span class="n">processed_24hz</span><span class="p">[:</span><span class="n">min_signal_length</span><span class="p">]</span>

    <span class="c1"># Bulk broadband signal alignment</span>
    <span class="n">reference_24hz</span><span class="p">,</span> <span class="n">processed_24hz</span> <span class="o">=</span> <span class="n">input_align</span><span class="p">(</span><span class="n">reference_24hz</span><span class="p">,</span> <span class="n">processed_24hz</span><span class="p">)</span>
    <span class="n">nsamp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_24hz</span><span class="p">)</span>

    <span class="c1"># For HASQI, here add NAL-R equalization if the quality reference doesn&#39;t</span>
    <span class="c1"># already have it.</span>
    <span class="k">if</span> <span class="n">itype</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nfir</span> <span class="o">=</span> <span class="mi">140</span>  <span class="c1"># Length in samples of the FIR NAL-R EQ filter (24-kHz rate)</span>
        <span class="n">enhancer</span> <span class="o">=</span> <span class="n">NALR</span><span class="p">(</span><span class="n">nfir</span><span class="p">,</span> <span class="n">freq_sample</span><span class="p">)</span>
        <span class="n">audiogram</span> <span class="o">=</span> <span class="n">Audiogram</span><span class="p">(</span>
            <span class="n">levels</span><span class="o">=</span><span class="n">hearing_loss</span><span class="p">,</span>
            <span class="n">frequencies</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">6000</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="n">nalr_fir</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">enhancer</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">audiogram</span><span class="p">)</span>
        <span class="n">reference_24hz</span> <span class="o">=</span> <span class="n">enhancer</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">nalr_fir</span><span class="p">,</span> <span class="n">reference_24hz</span><span class="p">)</span>
        <span class="n">reference_24hz</span> <span class="o">=</span> <span class="n">reference_24hz</span><span class="p">[</span><span class="n">nfir</span> <span class="p">:</span> <span class="n">nfir</span> <span class="o">+</span> <span class="n">nsamp</span><span class="p">]</span>

    <span class="c1"># Cochlear model</span>
    <span class="c1"># Middle ear</span>
    <span class="n">reference_mid</span> <span class="o">=</span> <span class="n">middle_ear</span><span class="p">(</span><span class="n">reference_24hz</span><span class="p">,</span> <span class="n">freq_sample</span><span class="p">)</span>
    <span class="n">processed_mid</span> <span class="o">=</span> <span class="n">middle_ear</span><span class="p">(</span><span class="n">processed_24hz</span><span class="p">,</span> <span class="n">freq_sample</span><span class="p">)</span>

    <span class="c1"># Initialize storage</span>
    <span class="c1"># Reference and processed envelopes and BM motion</span>
    <span class="n">reference_db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>
    <span class="n">processed_db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>

    <span class="c1"># Reference and processed average spectral values</span>
    <span class="n">reference_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>
    <span class="n">processed_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>
    <span class="n">reference_control_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>
    <span class="n">processed_control_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>

    <span class="c1"># Filter bandwidths adjusted for intensity</span>
    <span class="n">reference_bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>
    <span class="n">processed_bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>

    <span class="n">reference_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>
    <span class="n">processed_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>

    <span class="c1"># Loop over each filter in the auditory filter bank</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchan</span><span class="p">):</span>
        <span class="c1"># Control signal envelopes for the reference and processed signals</span>
        <span class="n">reference_control</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">processed_control</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gammatone_basilar_membrane</span><span class="p">(</span>
            <span class="n">reference_mid</span><span class="p">,</span>
            <span class="n">bandwidth_1</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">processed_mid</span><span class="p">,</span>
            <span class="n">bandwidth_1</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">freq_sample</span><span class="p">,</span>
            <span class="n">_center_freq_control</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Adjust the auditory filter bandwidths for the average signal level</span>
        <span class="n">reference_bandwidth</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">bandwidth_adjust</span><span class="p">(</span>
            <span class="n">reference_control</span><span class="p">,</span> <span class="n">bandwidth_min_x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">bandwidth_1</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">level1</span>
        <span class="p">)</span>
        <span class="n">processed_bandwidth</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">bandwidth_adjust</span><span class="p">(</span>
            <span class="n">processed_control</span><span class="p">,</span> <span class="n">bandwidth_min_y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">bandwidth_1</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">level1</span>
        <span class="p">)</span>

        <span class="c1"># Envelopes and BM motion of the reference and processed signals</span>
        <span class="n">xenv</span><span class="p">,</span> <span class="n">xbm</span><span class="p">,</span> <span class="n">yenv</span><span class="p">,</span> <span class="n">ybm</span> <span class="o">=</span> <span class="n">gammatone_basilar_membrane</span><span class="p">(</span>
            <span class="n">reference_mid</span><span class="p">,</span>
            <span class="n">reference_bandwidth</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">processed_mid</span><span class="p">,</span>
            <span class="n">processed_bandwidth</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">freq_sample</span><span class="p">,</span>
            <span class="n">_center_freq</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># RMS levels of the ref and output envelopes for linear metric</span>
        <span class="n">reference_average</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xenv</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">processed_average</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yenv</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">reference_control_average</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_control</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">processed_control_average</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">processed_control</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Cochlear compression for the signal envelopes and BM motion</span>
        <span class="n">reference_cochlear_compression</span><span class="p">,</span> <span class="n">reference_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">env_compress_basilar_membrane</span><span class="p">(</span>
            <span class="n">xenv</span><span class="p">,</span>
            <span class="n">xbm</span><span class="p">,</span>
            <span class="n">reference_control</span><span class="p">,</span>
            <span class="n">attn_ohc_x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">low_knee_x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">compression_ratio_x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">freq_sample</span><span class="p">,</span>
            <span class="n">level1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">processed_cochlear_compression</span><span class="p">,</span> <span class="n">processed_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">env_compress_basilar_membrane</span><span class="p">(</span>
            <span class="n">yenv</span><span class="p">,</span>
            <span class="n">ybm</span><span class="p">,</span>
            <span class="n">processed_control</span><span class="p">,</span>
            <span class="n">attn_ohc_y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">low_knee_y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">compression_ratio_y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
            <span class="n">freq_sample</span><span class="p">,</span>
            <span class="n">level1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Correct for the delay between the reference and output</span>
        <span class="n">processed_cochlear_compression</span> <span class="o">=</span> <span class="n">envelope_align</span><span class="p">(</span>
            <span class="n">reference_cochlear_compression</span><span class="p">,</span> <span class="n">processed_cochlear_compression</span>
        <span class="p">)</span>  <span class="c1"># Align processed envelope to reference</span>
        <span class="n">processed_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">envelope_align</span><span class="p">(</span>
            <span class="n">reference_b</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">processed_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># Align processed BM motion to reference</span>

        <span class="c1"># Convert the compressed envelopes and BM vibration envelopes to dB SPL</span>
        <span class="n">reference_cochlear_compression</span><span class="p">,</span> <span class="n">reference_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">envelope_sl</span><span class="p">(</span>
            <span class="n">reference_cochlear_compression</span><span class="p">,</span> <span class="n">reference_b</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">attn_ihc_x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">level1</span>
        <span class="p">)</span>
        <span class="n">processed_cochlear_compression</span><span class="p">,</span> <span class="n">processed_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">envelope_sl</span><span class="p">(</span>
            <span class="n">processed_cochlear_compression</span><span class="p">,</span> <span class="n">processed_b</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">attn_ihc_y</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">level1</span>
        <span class="p">)</span>

        <span class="c1"># Apply the IHC rapid and short-term adaptation</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Amount of overshoot</span>
        <span class="n">reference_db</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">reference_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">inner_hair_cell_adaptation</span><span class="p">(</span>
            <span class="n">reference_cochlear_compression</span><span class="p">,</span> <span class="n">reference_b</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">delta</span><span class="p">,</span> <span class="n">freq_sample</span>
        <span class="p">)</span>
        <span class="n">processed_db</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">processed_b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">inner_hair_cell_adaptation</span><span class="p">(</span>
            <span class="n">processed_cochlear_compression</span><span class="p">,</span> <span class="n">processed_b</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">delta</span><span class="p">,</span> <span class="n">freq_sample</span>
        <span class="p">)</span>

    <span class="c1"># Additive noise level to give the auditory threshold</span>
    <span class="n">ihc_threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>  <span class="c1"># Additive noise level, dB re: auditory threshold</span>
    <span class="n">reference_basilar_membrane</span> <span class="o">=</span> <span class="n">basilar_membrane_add_noise</span><span class="p">(</span>
        <span class="n">reference_b</span><span class="p">,</span> <span class="n">ihc_threshold</span><span class="p">,</span> <span class="n">level1</span>
    <span class="p">)</span>
    <span class="n">processed_basilar_membrane</span> <span class="o">=</span> <span class="n">basilar_membrane_add_noise</span><span class="p">(</span>
        <span class="n">processed_b</span><span class="p">,</span> <span class="n">ihc_threshold</span><span class="p">,</span> <span class="n">level1</span>
    <span class="p">)</span>

    <span class="c1"># Correct for the gammatone filterbank interchannel group delay.</span>
    <span class="k">if</span> <span class="n">m_delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">reference_db</span> <span class="o">=</span> <span class="n">group_delay_compensate</span><span class="p">(</span>
            <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_bandwidth</span><span class="p">,</span> <span class="n">_center_freq</span><span class="p">,</span> <span class="n">freq_sample</span>
        <span class="p">)</span>
        <span class="n">processed_db</span> <span class="o">=</span> <span class="n">group_delay_compensate</span><span class="p">(</span>
            <span class="n">processed_db</span><span class="p">,</span> <span class="n">reference_bandwidth</span><span class="p">,</span> <span class="n">_center_freq</span><span class="p">,</span> <span class="n">freq_sample</span>
        <span class="p">)</span>
        <span class="n">reference_basilar_membrane</span> <span class="o">=</span> <span class="n">group_delay_compensate</span><span class="p">(</span>
            <span class="n">reference_basilar_membrane</span><span class="p">,</span> <span class="n">reference_bandwidth</span><span class="p">,</span> <span class="n">_center_freq</span><span class="p">,</span> <span class="n">freq_sample</span>
        <span class="p">)</span>
        <span class="n">processed_basilar_membrane</span> <span class="o">=</span> <span class="n">group_delay_compensate</span><span class="p">(</span>
            <span class="n">processed_basilar_membrane</span><span class="p">,</span> <span class="n">reference_bandwidth</span><span class="p">,</span> <span class="n">_center_freq</span><span class="p">,</span> <span class="n">freq_sample</span>
        <span class="p">)</span>

    <span class="c1"># Convert average gammatone outputs to dB SPL</span>
    <span class="n">reference_sl</span> <span class="o">=</span> <span class="n">convert_rms_to_sl</span><span class="p">(</span>
        <span class="n">reference_average</span><span class="p">,</span>
        <span class="n">reference_control_average</span><span class="p">,</span>
        <span class="n">attn_ohc_x</span><span class="p">,</span>
        <span class="n">low_knee_x</span><span class="p">,</span>
        <span class="n">compression_ratio_x</span><span class="p">,</span>
        <span class="n">attn_ihc_x</span><span class="p">,</span>
        <span class="n">level1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">processed_sl</span> <span class="o">=</span> <span class="n">convert_rms_to_sl</span><span class="p">(</span>
        <span class="n">processed_average</span><span class="p">,</span>
        <span class="n">processed_control_average</span><span class="p">,</span>
        <span class="n">attn_ohc_y</span><span class="p">,</span>
        <span class="n">low_knee_y</span><span class="p">,</span>
        <span class="n">compression_ratio_y</span><span class="p">,</span>
        <span class="n">attn_ihc_y</span><span class="p">,</span>
        <span class="n">level1</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">reference_db</span><span class="p">,</span>
        <span class="n">reference_basilar_membrane</span><span class="p">,</span>
        <span class="n">processed_db</span><span class="p">,</span>
        <span class="n">processed_basilar_membrane</span><span class="p">,</span>
        <span class="n">reference_sl</span><span class="p">,</span>
        <span class="n">processed_sl</span><span class="p">,</span>
        <span class="n">freq_sample</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="center_frequency">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.center_frequency">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">center_frequency</span><span class="p">(</span>
    <span class="n">nchan</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">low_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">high_freq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
    <span class="n">ear_q</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">9.26449</span><span class="p">,</span>
    <span class="n">min_bw</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">24.7</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Equivalent Rectangular Bandwidth_[1] frequency spacing for the</span>
<span class="sd">    gammatone filter bank. The equation comes from Malcolm Slaney[2].</span>

<span class="sd">    Arguments:</span>
<span class="sd">        nchan (int): number of filters in the filter bank</span>
<span class="sd">        low_freq (int): Low Frequency level.</span>
<span class="sd">        high_freq (int): High Frequency level.</span>
<span class="sd">        shift (): optional frequency shift of the filter bank specified as a fractional</span>
<span class="sd">            shift in distance along the BM. A positive shift is an increase in frequency</span>
<span class="sd">            (basal shift), and negative is a decrease in frequency (apical shift). The</span>
<span class="sd">            total length of the BM is normalized to 1. The frequency-to-distance map is</span>
<span class="sd">            from D.D. Greenwood[3].</span>
<span class="sd">        ear_q (float):</span>
<span class="sd">        min_bw (float):</span>

<span class="sd">    Returns:</span>


<span class="sd">    References:</span>
<span class="sd">    .. [1] Moore BCJ, Glasberg BR (1983) Suggested formulae for calculating</span>
<span class="sd">           auditory-filter bandwidths and excitation patterns. J Acoustical</span>
<span class="sd">           Soc America 74:750-753. Available at</span>
<span class="sd">           &lt;https://doi.org/10.1121/1.389861&gt;</span>
<span class="sd">    .. [2] Slaney M (1993) An Efficient Implemtnation of the Patterson-</span>
<span class="sd">           Holdsworth Auditory Filter Bank. Available at:</span>
<span class="sd">           &lt;https://asset-pdf.scinapse.io/prod/396690109/396690109.pdf&gt;.</span>
<span class="sd">    .. [3] Greenwood DD (1990) A cochlear frequency-position function for</span>
<span class="sd">           several species--29 years later. J Acoust Soc Am 87(6):2592-</span>
<span class="sd">           2605. Available at</span>
<span class="sd">           &lt;https://doi.o10.1121/1.399052&gt;</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 25 January 2007.</span>
<span class="sd">    Frequency shift added 22 August 2008.</span>
<span class="sd">    Lower and upper frequencies fixed at 80 and 8000 Hz, 19 June 2012.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">165.4</span>  <span class="c1"># pylint: disable=invalid-name</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">2.1</span>  <span class="c1"># shift specified as a fraction of the total length</span>
        <span class="c1"># Locations of the low and high frequencies on the BM between 0 and 1</span>
        <span class="n">x_low</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">low_freq</span> <span class="o">/</span> <span class="n">A</span><span class="p">))</span>
        <span class="n">x_high</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">high_freq</span> <span class="o">/</span> <span class="n">A</span><span class="p">))</span>
        <span class="c1"># Shift the locations</span>
        <span class="n">x_low</span> <span class="o">=</span> <span class="n">x_low</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span>
        <span class="n">x_high</span> <span class="o">=</span> <span class="n">x_high</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span>
        <span class="c1"># Compute the new frequency range</span>
        <span class="n">low_freq</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x_low</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">high_freq</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x_high</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1"># All of the following expressions are derived in Apple TR #35,</span>
    <span class="c1"># &quot;An Efficient Implementation of the Patterson-Holdsworth Cochlear</span>
    <span class="c1"># Filter Bank&quot; by Malcolm Slaney.</span>
    <span class="c1"># https://engineering.purdue.edu/~malcolm/apple/tr35/PattersonsEar.pdf</span>
    <span class="n">_center_freq</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">ear_q</span> <span class="o">*</span> <span class="n">min_bw</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nchan</span><span class="p">)</span>
        <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">high_freq</span> <span class="o">+</span> <span class="n">ear_q</span> <span class="o">*</span> <span class="n">min_bw</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">low_freq</span> <span class="o">+</span> <span class="n">ear_q</span> <span class="o">*</span> <span class="n">min_bw</span><span class="p">))</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">nchan</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">high_freq</span> <span class="o">+</span> <span class="n">ear_q</span> <span class="o">*</span> <span class="n">min_bw</span><span class="p">)</span>
    <span class="n">_center_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
        <span class="n">_center_freq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">high_freq</span>
    <span class="p">)</span>  <span class="c1"># Last center frequency is set to highFreq</span>
    <span class="n">_center_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">_center_freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_center_freq</span></div>



<div class="viewcode-block" id="loss_parameters">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.loss_parameters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">loss_parameters</span><span class="p">(</span>
    <span class="n">hearing_loss</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">center_freq</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">audiometric_freq</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apportion the hearing loss to the outer hair cells (OHC) and the inner</span>
<span class="sd">    hair cells (IHC) and to increase the bandwidth of the cochlear filters</span>
<span class="sd">    in proportion to the OHC fraction of the total loss.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        hearing_loss (np.ndarray): hearing loss at the 6 audiometric frequencies</span>
<span class="sd">        center_freq (np.ndarray): array containing the center frequencies of the</span>
<span class="sd">            gammatone filters arranged from low to high</span>
<span class="sd">        audiometric_freq (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        attenuated_ohc (): attenuation in dB for the OHC gammatone filters</span>
<span class="sd">        bandwidth (): OHC filter bandwidth expressed in terms of normal</span>
<span class="sd">        low_knee (): Lower kneepoint for the low-level linear amplification</span>
<span class="sd">        compression_ratio (): Ranges from 1.4:1 at 150 Hz to 3.5:1 at 8 kHz for normal</span>
<span class="sd">            hearing. Reduced in proportion to the OHC loss to 1:1.</span>
<span class="sd">        attenuated_ihc ():	attenuation in dB for the input to the IHC synapse</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 25 January 2007.</span>
<span class="sd">    Version for loss in dB and match of OHC loss to CR, 9 March 2007.</span>
<span class="sd">    Low-frequency extent changed to 80 Hz, 27 Oct 2011.</span>
<span class="sd">    Lower kneepoint set to 30 dB, 19 June 2012.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Audiometric frequencies in Hz</span>
    <span class="k">if</span> <span class="n">audiometric_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">audiometric_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">250</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">6000</span><span class="p">])</span>

    <span class="c1"># Interpolation to give the loss at the gammatone center frequencies</span>
    <span class="c1"># Use linear interpolation in dB. The interpolation assumes that</span>
    <span class="c1"># cfreq[1] &lt; aud[1] and cfreq[nfilt] &gt; aud[6]</span>
    <span class="n">nfilt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">center_freq</span><span class="p">)</span>
    <span class="n">f_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
        <span class="n">audiometric_freq</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">audiometric_freq</span><span class="p">)],</span> <span class="p">[</span><span class="n">center_freq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center_freq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">)</span>

    <span class="c1"># Interpolated gain in dB</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
        <span class="n">center_freq</span><span class="p">,</span>
        <span class="n">f_v</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
            <span class="n">hearing_loss</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hearing_loss</span><span class="p">)],</span> <span class="p">[</span><span class="n">hearing_loss</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hearing_loss</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Make sure there are no negative losses</span>

    <span class="c1"># Compression ratio changes linearly with ERB rate from 1.25:1 in the 80-Hz</span>
    <span class="c1"># frequency band to 3.5:1 in the 8-kHz frequency band</span>
    <span class="n">compression_ratio</span> <span class="o">=</span> <span class="mf">1.25</span> <span class="o">+</span> <span class="mf">2.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nfilt</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nfilt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Maximum OHC sensitivity loss depends on the compression ratio. The compression</span>
    <span class="c1"># I/O curves assume linear below 30 and above 100 dB SPL in normal ears.</span>
    <span class="n">max_ohc</span> <span class="o">=</span> <span class="mi">70</span> <span class="o">*</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">compression_ratio</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># HC loss that results in 1:1 compression</span>
    <span class="n">theoretical_ohc</span> <span class="o">=</span> <span class="mf">1.25</span> <span class="o">*</span> <span class="n">max_ohc</span>  <span class="c1"># Loss threshold for adjusting the OHC parameters</span>

    <span class="c1"># Apportion the loss in dB to the outer and inner hair cells based on the data of</span>
    <span class="c1"># Moore et al (1999), JASA 106, 2761-2778.</span>

    <span class="c1"># Reduce the CR towards 1:1 in proportion to the OHC loss.</span>
    <span class="n">attenuated_ohc</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
    <span class="n">attenuated_ihc</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

    <span class="n">attenuated_ohc</span><span class="p">[</span><span class="n">loss</span> <span class="o">&gt;=</span> <span class="n">theoretical_ohc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mf">0.8</span> <span class="o">*</span> <span class="n">theoretical_ohc</span><span class="p">[</span><span class="n">loss</span> <span class="o">&gt;=</span> <span class="n">theoretical_ohc</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">attenuated_ihc</span><span class="p">[</span><span class="n">loss</span> <span class="o">&gt;=</span> <span class="n">theoretical_ohc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">theoretical_ohc</span><span class="p">[</span>
        <span class="n">loss</span> <span class="o">&gt;=</span> <span class="n">theoretical_ohc</span>
    <span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">loss</span><span class="p">[</span><span class="n">loss</span> <span class="o">&gt;=</span> <span class="n">theoretical_ohc</span><span class="p">]</span> <span class="o">-</span> <span class="n">theoretical_ohc</span><span class="p">[</span><span class="n">loss</span> <span class="o">&gt;=</span> <span class="n">theoretical_ohc</span><span class="p">])</span>

    <span class="c1"># Adjust the OHC bandwidth in proportion to the OHC loss</span>
    <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nfilt</span><span class="p">)</span>
    <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="o">+</span> <span class="p">(</span><span class="n">attenuated_ohc</span> <span class="o">/</span> <span class="mf">50.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">attenuated_ohc</span> <span class="o">/</span> <span class="mf">50.0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">6</span>

    <span class="c1"># Compute the compression lower kneepoint and compression ratio</span>
    <span class="n">low_knee</span> <span class="o">=</span> <span class="n">attenuated_ohc</span> <span class="o">+</span> <span class="mi">30</span>
    <span class="n">upamp</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">+</span> <span class="p">(</span><span class="mi">70</span> <span class="o">/</span> <span class="n">compression_ratio</span><span class="p">)</span>  <span class="c1"># Output level for an input of 100 dB SPL</span>

    <span class="n">compression_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">low_knee</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
        <span class="n">upamp</span> <span class="o">+</span> <span class="n">attenuated_ohc</span> <span class="o">-</span> <span class="n">low_knee</span>
    <span class="p">)</span>  <span class="c1"># OHC loss Compression ratio</span>

    <span class="k">return</span> <span class="n">attenuated_ohc</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">low_knee</span><span class="p">,</span> <span class="n">compression_ratio</span><span class="p">,</span> <span class="n">attenuated_ihc</span></div>



<div class="viewcode-block" id="resample_24khz">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.resample_24khz">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">resample_24khz</span><span class="p">(</span>
    <span class="n">reference_signal</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">reference_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">freq_sample_hz</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">24000.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample the input signal at 24 kHz. The input sampling rate is</span>
<span class="sd">    rounded to the nearest kHz to compute the sampling rate conversion</span>
<span class="sd">    ratio.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    reference_signal (np.ndarray): input signal</span>
<span class="sd">    reference_freq (int): sampling rate for the input in Hz</span>
<span class="sd">    freq_sample_hz (int): Frequency sample in Hz</span>

<span class="sd">    Returns:</span>
<span class="sd">    reference_signal_24         signal resampled at kHz (default 24Khz)</span>
<span class="sd">    freq_sample_hz     output sampling rate in Hz</span>

<span class="sd">    Updates</span>
<span class="sd">    James M. Kates, 20 June 2011.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Sampling rate information</span>
    <span class="n">sample_rate_target_khz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
        <span class="n">freq_sample_hz</span> <span class="o">/</span> <span class="mi">1000</span>
    <span class="p">)</span>  <span class="c1"># output rate to nearest kHz</span>
    <span class="n">reference_freq_khz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">reference_freq</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># Resample the signal</span>
    <span class="k">if</span> <span class="n">reference_freq_khz</span> <span class="o">==</span> <span class="n">sample_rate_target_khz</span><span class="p">:</span>
        <span class="c1"># No resampling performed if the rates match</span>
        <span class="k">return</span> <span class="n">reference_signal</span><span class="p">,</span> <span class="n">freq_sample_hz</span>

    <span class="k">if</span> <span class="n">reference_freq_khz</span> <span class="o">&lt;</span> <span class="n">sample_rate_target_khz</span><span class="p">:</span>
        <span class="c1"># Resample for the input rate lower than the output</span>
        <span class="n">resample_signal</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span>
            <span class="n">reference_signal</span><span class="p">,</span> <span class="n">sample_rate_target_khz</span><span class="p">,</span> <span class="n">reference_freq_khz</span>
        <span class="p">)</span>

        <span class="c1"># Match the RMS level of the resampled signal to that of the input</span>
        <span class="n">reference_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_signal</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">resample_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">resample_signal</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">resample_signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">reference_rms</span> <span class="o">/</span> <span class="n">resample_rms</span><span class="p">)</span> <span class="o">*</span> <span class="n">resample_signal</span>

        <span class="k">return</span> <span class="n">resample_signal</span><span class="p">,</span> <span class="n">freq_sample_hz</span>

    <span class="c1"># Resample for the input rate higher than the output</span>
    <span class="n">resample_signal</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span>
        <span class="n">reference_signal</span><span class="p">,</span> <span class="n">sample_rate_target_khz</span><span class="p">,</span> <span class="n">reference_freq_khz</span>
    <span class="p">)</span>

    <span class="c1"># Reduce the input signal bandwidth to 21 kHz (-10.5 to +10.5 kHz)</span>
    <span class="c1"># The power equalization is designed to match the signal intensities</span>
    <span class="c1"># over the frequency range spanned by the gammatone filter bank.</span>
    <span class="c1"># Chebyshev Type 2 LP</span>
    <span class="n">order</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c1"># sidelobe attenuation in dB</span>
    <span class="n">reference_freq_cut</span> <span class="o">=</span> <span class="mi">21</span> <span class="o">/</span> <span class="n">reference_freq_khz</span>
    <span class="n">reference_b</span><span class="p">,</span> <span class="n">reference_a</span> <span class="o">=</span> <span class="n">cheby2</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">,</span> <span class="n">reference_freq_cut</span><span class="p">)</span>
    <span class="n">reference_filter</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">reference_b</span><span class="p">,</span> <span class="n">reference_a</span><span class="p">,</span> <span class="n">reference_signal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Reduce the resampled signal bandwidth to 21 kHz (-10.5 to +10.5 kHz)</span>
    <span class="n">resample_rate_cut</span> <span class="o">=</span> <span class="mi">21</span> <span class="o">/</span> <span class="n">sample_rate_target_khz</span>
    <span class="n">target_b</span><span class="p">,</span> <span class="n">target_a</span> <span class="o">=</span> <span class="n">cheby2</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">,</span> <span class="n">resample_rate_cut</span><span class="p">)</span>
    <span class="n">target_filter</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">target_b</span><span class="p">,</span> <span class="n">target_a</span><span class="p">,</span> <span class="n">resample_signal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute the input and output RMS levels within the 21 kHz bandwidth and</span>
    <span class="c1"># match the output to the input</span>
    <span class="n">reference_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_filter</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">resample_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">target_filter</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">resample_signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">reference_rms</span> <span class="o">/</span> <span class="n">resample_rms</span><span class="p">)</span> <span class="o">*</span> <span class="n">resample_signal</span>

    <span class="k">return</span> <span class="n">resample_signal</span><span class="p">,</span> <span class="n">freq_sample_hz</span></div>



<div class="viewcode-block" id="input_align">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.input_align">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">input_align</span><span class="p">(</span><span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">processed</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Approximate temporal alignment of the reference and processed output</span>
<span class="sd">    signals. Leading and trailing zeros are then pruned.</span>

<span class="sd">    The function assumes that the two sequences have the same sampling rate:</span>
<span class="sd">    call eb_Resamp24kHz for each sequence first, then call this function to</span>
<span class="sd">    align the signals.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    reference (np.ndarray): input reference sequence</span>
<span class="sd">    processed (np.ndarray): hearing-aid output sequence</span>

<span class="sd">    Returns:</span>
<span class="sd">    reference (np.ndarray): pruned and shifted reference</span>
<span class="sd">    processed (np.ndarray): pruned and shifted hearing-aid output</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 12 July 2011.</span>
<span class="sd">    Match the length of the processed output to the reference for the</span>
<span class="sd">    purposes of computing the cross-covariance</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Match the length of the processed output to the reference for the purposes</span>
    <span class="c1"># of computing the cross-covariance</span>
    <span class="n">reference_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
    <span class="n">processed_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
    <span class="n">min_sample_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">reference_n</span><span class="p">,</span> <span class="n">processed_n</span><span class="p">)</span>

    <span class="c1"># Determine the delay of the output relative to the reference</span>
    <span class="n">reference_processed_correlation</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span>
        <span class="n">reference</span><span class="p">[:</span><span class="n">min_sample_length</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference</span><span class="p">[:</span><span class="n">min_sample_length</span><span class="p">]),</span>
        <span class="n">processed</span><span class="p">[:</span><span class="n">min_sample_length</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">processed</span><span class="p">[:</span><span class="n">min_sample_length</span><span class="p">]),</span>
        <span class="s2">&quot;full&quot;</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># Matlab code uses xcov thus the subtraction of mean</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference_processed_correlation</span><span class="p">))</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">min_sample_length</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Back up 2 msec to allow for dispersion</span>
    <span class="n">fsamp</span> <span class="o">=</span> <span class="mf">24000.0</span>  <span class="c1"># Cochlear model input sampling rate in Hz</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">delay</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">fsamp</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Back up 2 ms</span>

    <span class="c1"># Align the output with the reference allowing for the dispersion</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Output delayed relative to the reference</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">processed</span><span class="p">[</span><span class="n">delay</span><span class="p">:</span><span class="n">processed_n</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">delay</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Output advanced relative to the reference</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">-</span><span class="n">delay</span><span class="p">),</span> <span class="n">processed</span><span class="p">[:</span> <span class="n">processed_n</span> <span class="o">+</span> <span class="n">delay</span><span class="p">]))</span>

    <span class="c1"># Find the start and end of the noiseless reference sequence</span>
    <span class="n">reference_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
    <span class="n">reference_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">reference_abs</span><span class="p">)</span>
    <span class="n">reference_threshold</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">reference_max</span>  <span class="c1"># Zero detection threshold</span>

    <span class="n">above_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">reference_abs</span> <span class="o">&gt;</span> <span class="n">reference_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reference_n_above_threshold</span> <span class="o">=</span> <span class="n">above_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reference_n_below_threshold</span> <span class="o">=</span> <span class="n">above_threshold</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Prune the sequences to remove the leading and trailing zeros</span>
    <span class="n">reference_n_below_threshold</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">reference_n_below_threshold</span><span class="p">,</span> <span class="n">processed_n</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">reference</span><span class="p">[</span><span class="n">reference_n_above_threshold</span> <span class="p">:</span> <span class="n">reference_n_below_threshold</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">processed</span><span class="p">[</span><span class="n">reference_n_above_threshold</span> <span class="p">:</span> <span class="n">reference_n_below_threshold</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="middle_ear">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.middle_ear">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">middle_ear</span><span class="p">(</span><span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">freq_sample</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Design the middle ear filters and process the input through the</span>
<span class="sd">    cascade of filters. The middle ear model is a 2-pole HP filter</span>
<span class="sd">    at 350 Hz in series with a 1-pole LP filter at 5000 Hz. The</span>
<span class="sd">    result is a rough approximation to the equal-loudness contour</span>
<span class="sd">    at threshold.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    reference (np.ndarray):	input signal</span>
<span class="sd">    freq_sample (float): sampling rate in Hz</span>

<span class="sd">    Returns:</span>
<span class="sd">    xout (): filtered output</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 18 January 2007.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Design the 1-pole Butterworth LP using the bilinear transformation</span>
    <span class="n">butterworth_low_pass</span><span class="p">,</span> <span class="n">low_pass</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5000</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">freq_sample</span><span class="p">))</span>

    <span class="c1"># LP filter the input</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">butterworth_low_pass</span><span class="p">,</span> <span class="n">low_pass</span><span class="p">,</span> <span class="n">reference</span><span class="p">)</span>

    <span class="c1"># Design the 2-pole Butterworth HP using the bilinear transformation</span>
    <span class="n">butterworth_high_pass</span><span class="p">,</span> <span class="n">high_pass</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">350</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">freq_sample</span><span class="p">),</span> <span class="s2">&quot;high&quot;</span><span class="p">)</span>

    <span class="c1"># HP filter the signal</span>
    <span class="k">return</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">butterworth_high_pass</span><span class="p">,</span> <span class="n">high_pass</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>



<div class="viewcode-block" id="gammatone_basilar_membrane">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.gammatone_basilar_membrane">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gammatone_basilar_membrane</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">reference_bandwidth</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">processed</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">processed_bandwidth</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">freq_sample</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">center_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">ear_q</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">9.26449</span><span class="p">,</span>
    <span class="n">min_bandwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">24.7</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    4th-order gammatone auditory filter. This implementation is based on the c program</span>
<span class="sd">    published on-line by Ning Ma, U. Sheffield, UK[1]_ that gives an implementation of</span>
<span class="sd">    the Martin Cooke filters[2]_: an impulse-invariant transformation of the gammatone</span>
<span class="sd">    filter. The signal is demodulated down to baseband using a complex exponential,</span>
<span class="sd">    and then passed through a cascade of four one-pole low-pass filters.</span>

<span class="sd">    This version filters two signals that have the same sampling rate and the same</span>
<span class="sd">    gammatone filter center frequencies. The lengths of the two signals should match;</span>
<span class="sd">    if they don&#39;t, the signals are truncated to the shorter of the two lengths.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (): first sequence to be filtered</span>
<span class="sd">        reference_bandwidth: bandwidth for x relative to that of a normal ear</span>
<span class="sd">        processed (): second sequence to be filtered</span>
<span class="sd">        processed_bandwidth (): bandwidth for x relative to that of a normal ear</span>
<span class="sd">        freq_sample (): sampling rate in Hz</span>
<span class="sd">        center_frequency (int): filter center frequency in Hz</span>
<span class="sd">        ear_q: (float): ???</span>
<span class="sd">        min_bandwidth (float): ???</span>

<span class="sd">    Returns:</span>
<span class="sd">        reference_envelope (): filter envelope output (modulated down to baseband)</span>
<span class="sd">            1st signal</span>
<span class="sd">        reference_basilar_membrane (): Basilar Membrane for the first signal</span>
<span class="sd">        processed_envelope (): filter envelope output (modulated down to baseband)</span>
<span class="sd">            2nd signal</span>
<span class="sd">        processed_basilar_membrane (): Basilar Membrane for the second signal</span>

<span class="sd">    References:</span>
<span class="sd">    .. [1] Ma N, Green P, Barker J, Coy A (2007) Exploiting correlogram</span>
<span class="sd">           structure for robust speech recognition with multiple speech</span>
<span class="sd">           sources. Speech Communication, 49 (12): 874-891. Available at</span>
<span class="sd">           &lt;https://doi.org/10.1016/j.specom.2007.05.003&gt;</span>
<span class="sd">           &lt;https://staffwww.dcs.shef.ac.uk/people/N.Ma/resources/gammatone/&gt;</span>
<span class="sd">    .. [2] Cooke, M. (1993) Modelling auditory processing and organisation.</span>
<span class="sd">           Cambridge University Press</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 8 Jan 2007.</span>
<span class="sd">    Vectorized version for efficient MATLAB execution, 4 February 2007.</span>
<span class="sd">    Cosine and sine generation, 29 June 2011.</span>
<span class="sd">    Output sine and cosine sequences, 19 June 2012.</span>
<span class="sd">    Cosine/sine loop speed increased, 9 August 2013.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Filter Equivalent Rectangular Bandwidth from Moore and Glasberg (1983)</span>
    <span class="c1"># doi: 10.1121/1.389861</span>
    <span class="n">erb</span> <span class="o">=</span> <span class="n">min_bandwidth</span> <span class="o">+</span> <span class="p">(</span><span class="n">center_freq</span> <span class="o">/</span> <span class="n">ear_q</span><span class="p">)</span>

    <span class="c1"># Check the lengths of the two signals and trim to shortest</span>
    <span class="n">min_sample</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[:</span><span class="n">min_sample</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">processed</span><span class="p">[:</span><span class="n">min_sample</span><span class="p">]</span>

    <span class="c1"># Filter the first signal</span>
    <span class="c1"># Initialize the filter coefficients</span>
    <span class="n">tpt</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">freq_sample</span>
    <span class="n">tpt_bw</span> <span class="o">=</span> <span class="n">reference_bandwidth</span> <span class="o">*</span> <span class="n">tpt</span> <span class="o">*</span> <span class="n">erb</span> <span class="o">*</span> <span class="mf">1.019</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tpt_bw</span><span class="p">)</span>
    <span class="n">a_1</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_3</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_4</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_5</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a_1</span> <span class="o">-</span> <span class="n">a_2</span> <span class="o">-</span> <span class="n">a_3</span> <span class="o">-</span> <span class="n">a_4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a_1</span> <span class="o">+</span> <span class="n">a_5</span><span class="p">)</span>

    <span class="c1"># Initialize the complex demodulation</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">sincf</span><span class="p">,</span> <span class="n">coscf</span> <span class="o">=</span> <span class="n">gammatone_bandwidth_demodulation</span><span class="p">(</span>
        <span class="n">npts</span><span class="p">,</span> <span class="n">tpt</span><span class="p">,</span> <span class="n">center_freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Filter the real and imaginary parts of the signal</span>
    <span class="n">ureal</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_2</span><span class="p">,</span> <span class="o">-</span><span class="n">a_3</span><span class="p">,</span> <span class="o">-</span><span class="n">a_4</span><span class="p">],</span> <span class="n">x</span> <span class="o">*</span> <span class="n">coscf</span><span class="p">)</span>
    <span class="n">uimag</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_2</span><span class="p">,</span> <span class="o">-</span><span class="n">a_3</span><span class="p">,</span> <span class="o">-</span><span class="n">a_4</span><span class="p">],</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sincf</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ureal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>  <span class="c1"># lfilter can return different types</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uimag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="c1"># Extract the BM velocity and the envelope</span>
    <span class="n">reference_basilar_membrane</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">ureal</span> <span class="o">*</span> <span class="n">coscf</span> <span class="o">+</span> <span class="n">uimag</span> <span class="o">*</span> <span class="n">sincf</span><span class="p">)</span>
    <span class="n">reference_envelope</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ureal</span> <span class="o">*</span> <span class="n">ureal</span> <span class="o">+</span> <span class="n">uimag</span> <span class="o">*</span> <span class="n">uimag</span><span class="p">)</span>

    <span class="c1"># Filter the second signal using the existing cosine and sine sequences</span>
    <span class="n">tpt_bw</span> <span class="o">=</span> <span class="n">processed_bandwidth</span> <span class="o">*</span> <span class="n">tpt</span> <span class="o">*</span> <span class="n">erb</span> <span class="o">*</span> <span class="mf">1.019</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tpt_bw</span><span class="p">)</span>
    <span class="n">a_1</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_3</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_4</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_5</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a_1</span> <span class="o">-</span> <span class="n">a_2</span> <span class="o">-</span> <span class="n">a_3</span> <span class="o">-</span> <span class="n">a_4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a_1</span> <span class="o">+</span> <span class="n">a_5</span><span class="p">)</span>

    <span class="c1"># Filter the real and imaginary parts of the signal</span>
    <span class="n">ureal</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_2</span><span class="p">,</span> <span class="o">-</span><span class="n">a_3</span><span class="p">,</span> <span class="o">-</span><span class="n">a_4</span><span class="p">],</span> <span class="n">y</span> <span class="o">*</span> <span class="n">coscf</span><span class="p">)</span>
    <span class="n">uimag</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span> <span class="n">a_5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_2</span><span class="p">,</span> <span class="o">-</span><span class="n">a_3</span><span class="p">,</span> <span class="o">-</span><span class="n">a_4</span><span class="p">],</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sincf</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ureal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uimag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="c1"># Extract the BM velocity and the envelope</span>
    <span class="n">processed_basilar_membrane</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">ureal</span> <span class="o">*</span> <span class="n">coscf</span> <span class="o">+</span> <span class="n">uimag</span> <span class="o">*</span> <span class="n">sincf</span><span class="p">)</span>
    <span class="n">processed_envelope</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ureal</span> <span class="o">*</span> <span class="n">ureal</span> <span class="o">+</span> <span class="n">uimag</span> <span class="o">*</span> <span class="n">uimag</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">reference_envelope</span><span class="p">,</span>
        <span class="n">reference_basilar_membrane</span><span class="p">,</span>
        <span class="n">processed_envelope</span><span class="p">,</span>
        <span class="n">processed_basilar_membrane</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="gammatone_bandwidth_demodulation">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.gammatone_bandwidth_demodulation">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">gammatone_bandwidth_demodulation</span><span class="p">(</span>
    <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">tpt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">center_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">center_freq_cos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">center_freq_sin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the carriers for demodulaton, using the 2d Rotation method from</span>
<span class="sd">      https://ccrma.stanford.edu/~jos/pasp/Digital_Sinusoid_Generators.html</span>
<span class="sd">    to generate the sin and cos components.  More efficient, perhaps, than</span>
<span class="sd">    calculating the sin and cos at each point in time.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        npts (): How many points are needed.</span>
<span class="sd">        tpt (): Phase change (2pi/T) due to each sample time.</span>
<span class="sd">        center_freq (): The carrier frequency</span>
<span class="sd">        center_freq_cos (): Array to overwrite for the output.</span>
<span class="sd">        center_freq_sin (): Array to overwrite for the output.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sincf (): Samples of the carrier frequency in sin phase.</span>
<span class="sd">        coscf (): Samples of the carrier frequency in cos phase.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cos_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">tpt</span> <span class="o">*</span> <span class="n">center_freq</span><span class="p">)</span>
    <span class="n">sin_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tpt</span> <span class="o">*</span> <span class="n">center_freq</span><span class="p">)</span>
    <span class="n">cold</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">sold</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">center_freq_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cold</span>
    <span class="n">center_freq_sin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sold</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">cold</span> <span class="o">*</span> <span class="n">cos_n</span> <span class="o">+</span> <span class="n">sold</span> <span class="o">*</span> <span class="n">sin_n</span>
        <span class="n">sold</span> <span class="o">=</span> <span class="n">sold</span> <span class="o">*</span> <span class="n">cos_n</span> <span class="o">-</span> <span class="n">cold</span> <span class="o">*</span> <span class="n">sin_n</span>
        <span class="n">cold</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="n">center_freq_cos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">cold</span>
        <span class="n">center_freq_sin</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sold</span>

    <span class="k">return</span> <span class="n">center_freq_sin</span><span class="p">,</span> <span class="n">center_freq_cos</span></div>



<div class="viewcode-block" id="bandwidth_adjust">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.bandwidth_adjust">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bandwidth_adjust</span><span class="p">(</span>
    <span class="n">control</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">bandwidth_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">bandwidth_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">level1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the increase in auditory filter bandwidth in response to high signal</span>
<span class="sd">    levels.  The RMS of the control signal, a scalar, is used to set the</span>
<span class="sd">    bandwidth for the entire signal.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        control (): envelope output in the control filter band</span>
<span class="sd">        bandwidth_min (): auditory filter bandwidth computed for the loss (or NH)</span>
<span class="sd">        bandwidth_max (): auditory filter bandwidth at maximum OHC damage</span>
<span class="sd">        level1 ():     RMS=1 corresponds to Level1 dB SPL</span>

<span class="sd">    Returns:</span>
<span class="sd">        bandwidth (): filter bandwidth increased for high signal levels</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 21 June 2011.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute the control signal level</span>
    <span class="n">control_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">control</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">control_db</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">control_rms</span><span class="p">)</span> <span class="o">+</span> <span class="n">level1</span>

    <span class="c1"># Adjust the auditory filter bandwidth</span>
    <span class="k">if</span> <span class="n">control_db</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">:</span>
        <span class="c1"># No BW adjustment for a signal below 50 dB SPL</span>
        <span class="k">return</span> <span class="n">bandwidth_min</span>
    <span class="k">if</span> <span class="n">control_db</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="c1"># Maximum BW if signal is above 100 dB SPL</span>
        <span class="k">return</span> <span class="n">bandwidth_max</span>
    <span class="k">return</span> <span class="n">bandwidth_min</span> <span class="o">+</span> <span class="p">((</span><span class="n">control_db</span> <span class="o">-</span> <span class="mi">50</span><span class="p">)</span> <span class="o">/</span> <span class="mi">50</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">bandwidth_max</span> <span class="o">-</span> <span class="n">bandwidth_min</span><span class="p">)</span></div>



<div class="viewcode-block" id="env_compress_basilar_membrane">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.env_compress_basilar_membrane">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">env_compress_basilar_membrane</span><span class="p">(</span>
    <span class="n">envsig</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">bm</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">control</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">attn_ohc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">threshold_low</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">compression_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">fsamp</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">level1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">small</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-30</span><span class="p">,</span>
    <span class="n">threshold_high</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cochlear compression in one auditory filter band. The gain is linear</span>
<span class="sd">    below the lower threshold, compressive with a compression ratio of CR:1 between the</span>
<span class="sd">    lower and upper thresholds, and reverts to linear above the upper threshold. The</span>
<span class="sd">    compressor assumes that auditory threshold is 0 dB SPL.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        envsig (): analytic signal envelope (magnitude) returned by the</span>
<span class="sd">                gammatone filter bank</span>
<span class="sd">        bm (): BM motion output by the filter bank</span>
<span class="sd">        control (): analytic control envelope returned by the wide control</span>
<span class="sd">                path filter bank</span>
<span class="sd">        attn_ohc (): OHC attenuation at the input to the compressor</span>
<span class="sd">        threshold_Low (): kneepoint for the low-level linear amplification</span>
<span class="sd">        compression_ratio (): compression ratio</span>
<span class="sd">        fsamp (): sampling rate in Hz</span>
<span class="sd">        level1 (): dB reference level: a signal having an RMS value of 1 is</span>
<span class="sd">                assigned to Level1 dB SPL.</span>
<span class="sd">        small (): ???</span>
<span class="sd">        threshold_high: kneepoint for the high-level linear amplification</span>

<span class="sd">    Returns:</span>
<span class="sd">        compressed_signal (): compressed version of the signal envelope</span>
<span class="sd">        compressed_basilar_membrane (): compressed version of the BM motion</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 19 January 2007.</span>
<span class="sd">    LP filter added 15 Feb 2007 (Ref: Zhang et al., 2001)</span>
<span class="sd">    Version to compress the envelope, 20 Feb 2007.</span>
<span class="sd">    Change in the OHC I/O function, 9 March 2007.</span>
<span class="sd">    Two-tone suppression added 22 August 2008.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert the control envelope to dB SPL</span>
    <span class="n">logenv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">small</span><span class="p">)</span>
    <span class="n">logenv</span> <span class="o">=</span> <span class="n">level1</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">logenv</span><span class="p">)</span>
    <span class="n">logenv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
        <span class="n">logenv</span><span class="p">,</span> <span class="n">threshold_high</span>
    <span class="p">)</span>  <span class="c1"># Clip signal levels above the upper threshold</span>
    <span class="n">logenv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">logenv</span><span class="p">,</span> <span class="n">threshold_low</span><span class="p">)</span>  <span class="c1"># Clip signal at the lower threshold</span>

    <span class="c1"># Compute the compression gain in dB</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="o">-</span><span class="n">attn_ohc</span> <span class="o">-</span> <span class="p">(</span><span class="n">logenv</span> <span class="o">-</span> <span class="n">threshold_low</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">compression_ratio</span><span class="p">))</span>

    <span class="c1"># Convert the gain to linear and apply a LP filter to give a 0.2 ms delay</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">gain</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">flp</span> <span class="o">=</span> <span class="mi">800</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">butter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">flp</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fsamp</span><span class="p">))</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">gain</span><span class="p">)</span>

    <span class="c1"># Apply the gain to the signals</span>
    <span class="n">compressed_signal</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">envsig</span>
    <span class="n">compressed_basilar_membrane</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">bm</span>

    <span class="k">return</span> <span class="n">compressed_signal</span><span class="p">,</span> <span class="n">compressed_basilar_membrane</span></div>



<div class="viewcode-block" id="envelope_align">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.envelope_align">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">envelope_align</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">output</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">freq_sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">24000</span><span class="p">,</span> <span class="n">corr_range</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Align the envelope of the processed signal to that of the reference signal.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (): envelope or BM motion of the reference signal</span>
<span class="sd">        output (): envelope or BM motion of the output signal</span>
<span class="sd">        freq_sample (int): Frequency sample rate in Hz</span>
<span class="sd">        corr_range (int): range in msec for the correlation</span>

<span class="sd">    Returns:</span>
<span class="sd">        y (): shifted output envelope to match the input</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 28 October 2011.</span>
<span class="sd">    Absolute value of the cross-correlation peak removed, 22 June 2012.</span>
<span class="sd">    Cross-correlation range reduced, 13 August 2013.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The MATLAB code limits the range of lags to search (to 100 ms) to save computation</span>
    <span class="c1"># time - no such option exists in numpy, but the code below limits the delay to the</span>
    <span class="c1"># same range as in Matlab, for consistent results</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="mf">0.001</span> <span class="o">*</span> <span class="n">corr_range</span> <span class="o">*</span> <span class="n">freq_sample</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Range in samples</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
    <span class="n">lags</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>

    <span class="n">ref_out_correlation</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
    <span class="n">location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
        <span class="n">ref_out_correlation</span><span class="p">[</span><span class="n">npts</span> <span class="o">-</span> <span class="n">lags</span> <span class="p">:</span> <span class="n">npts</span> <span class="o">+</span> <span class="n">lags</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># Limit the range in which</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">lags</span> <span class="o">-</span> <span class="n">location</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Time shift the output sequence</span>
    <span class="k">if</span> <span class="n">delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Output delayed relative to the reference</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">output</span><span class="p">[</span><span class="n">delay</span><span class="p">:</span><span class="n">npts</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">delay</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">-</span><span class="n">delay</span><span class="p">),</span> <span class="n">output</span><span class="p">[:</span> <span class="n">npts</span> <span class="o">+</span> <span class="n">delay</span><span class="p">]))</span></div>



<div class="viewcode-block" id="envelope_sl">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.envelope_sl">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">envelope_sl</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">basilar_membrane</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">attenuated_ihc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">level1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">small</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-30</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the compressed envelope returned by cochlear_envcomp to dB SL.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (): linear envelope after compression</span>
<span class="sd">        basilar_membrane (): linear Basilar Membrane vibration after compression</span>
<span class="sd">        attenuated_ihc (): IHC attenuation at the input to the synapse</span>
<span class="sd">        level1 (): level in dB SPL corresponding to 1 RMS</span>
<span class="sd">        small (float): ???</span>

<span class="sd">    Returns:</span>
<span class="sd">        _reference (): reference envelope in dB SL</span>
<span class="sd">        _basilar_membrane (): Basilar Membrane vibration with envelope converted to</span>
<span class="sd">            dB SL</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 20 Feb 07.</span>
<span class="sd">    IHC attenuation added 9 March 2007.</span>
<span class="sd">    Basilar membrane vibration conversion added 2 October 2012.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert the envelope to dB SL</span>
    <span class="n">_reference</span> <span class="o">=</span> <span class="n">level1</span> <span class="o">-</span> <span class="n">attenuated_ihc</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">reference</span> <span class="o">+</span> <span class="n">small</span><span class="p">)</span>
    <span class="n">_reference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">_reference</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Convert the linear BM motion to have a dB SL envelope</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="p">(</span><span class="n">_reference</span> <span class="o">+</span> <span class="n">small</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">reference</span> <span class="o">+</span> <span class="n">small</span><span class="p">)</span>
    <span class="n">_basilar_membrane</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">basilar_membrane</span>

    <span class="k">return</span> <span class="n">_reference</span><span class="p">,</span> <span class="n">_basilar_membrane</span></div>



<div class="viewcode-block" id="inner_hair_cell_adaptation">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.inner_hair_cell_adaptation">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inner_hair_cell_adaptation</span><span class="p">(</span>
    <span class="n">reference_db</span><span class="p">,</span> <span class="n">reference_basilar_membrane</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">freq_sample</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provide inner hair cell (IHC) adaptation. The adaptation is based on an</span>
<span class="sd">    equivalent RC circuit model, and the derivatives are mapped into</span>
<span class="sd">    1st-order backward differences. Rapid and short-term adaptation are</span>
<span class="sd">    provided. The input is the signal envelope in dB SL, with IHC attenuation</span>
<span class="sd">    already applied to the envelope. The outputs are the envelope in dB SL</span>
<span class="sd">    with adaptation providing overshoot of the long-term output level, and</span>
<span class="sd">    the BM motion is multiplied by a gain vs. time function that reproduces</span>
<span class="sd">    the adaptation. IHC attenuation and additive noise for the equivalent</span>
<span class="sd">    auditory threshold are provided by a subsequent call to eb_BMatten.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference_db (np.ndarray): signal envelope in one frequency band in dB SL</span>
<span class="sd">             contains OHC compression and IHC attenuation</span>
<span class="sd">        reference_basilar_membrane (): basilar membrane vibration with OHC compression</span>
<span class="sd">            but no IHC attenuation</span>
<span class="sd">        delta (): overshoot factor = delta x steady-state</span>
<span class="sd">        freq_sample (int): sampling rate in Hz</span>

<span class="sd">    Returns:</span>
<span class="sd">        output_db (): envelope in dB SL with IHC adaptation</span>
<span class="sd">        output_basilar_membrane (): Basilar Membrane multiplied by the IHC adaptation</span>
<span class="sd">            gain function</span>

<span class="sd">    Updates:</span>
<span class="sd">    James M. Kates, 1 October 2012.</span>
<span class="sd">    Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Test the amount of overshoot</span>
    <span class="n">dsmall</span> <span class="o">=</span> <span class="mf">1.0001</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">dsmall</span><span class="p">)</span>

    <span class="c1"># Initialize adaptation time constants</span>
    <span class="n">tau1</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Rapid adaptation in msec</span>
    <span class="n">tau2</span> <span class="o">=</span> <span class="mi">60</span>  <span class="c1"># Short-term adaptation in msec</span>
    <span class="n">tau1</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">tau1</span>  <span class="c1"># Convert to seconds</span>
    <span class="n">tau2</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">tau2</span>

    <span class="c1"># Equivalent circuit parameters</span>
    <span class="n">freq_sample_inverse</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">freq_sample</span>
    <span class="n">r_1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">delta</span>
    <span class="n">r_2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r_1</span><span class="p">)</span>
    <span class="n">r_3</span> <span class="o">=</span> <span class="n">r_2</span>
    <span class="n">c_1</span> <span class="o">=</span> <span class="n">tau1</span> <span class="o">*</span> <span class="p">(</span><span class="n">r_1</span> <span class="o">+</span> <span class="n">r_2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r_1</span> <span class="o">*</span> <span class="n">r_2</span><span class="p">)</span>
    <span class="n">c_2</span> <span class="o">=</span> <span class="n">tau2</span> <span class="o">/</span> <span class="p">((</span><span class="n">r_1</span> <span class="o">+</span> <span class="n">r_2</span><span class="p">)</span> <span class="o">*</span> <span class="n">r_3</span><span class="p">)</span>

    <span class="c1"># Intermediate values used for the voltage update matrix inversion</span>
    <span class="n">a11</span> <span class="o">=</span> <span class="n">r_1</span> <span class="o">+</span> <span class="n">r_2</span> <span class="o">+</span> <span class="n">r_1</span> <span class="o">*</span> <span class="n">r_2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_1</span> <span class="o">/</span> <span class="n">freq_sample_inverse</span><span class="p">)</span>
    <span class="n">a12</span> <span class="o">=</span> <span class="o">-</span><span class="n">r_1</span>
    <span class="n">a21</span> <span class="o">=</span> <span class="o">-</span><span class="n">r_3</span>
    <span class="n">a22</span> <span class="o">=</span> <span class="n">r_2</span> <span class="o">+</span> <span class="n">r_3</span> <span class="o">+</span> <span class="n">r_2</span> <span class="o">*</span> <span class="n">r_3</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_2</span> <span class="o">/</span> <span class="n">freq_sample_inverse</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">a11</span> <span class="o">*</span> <span class="n">a22</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">a21</span> <span class="o">*</span> <span class="n">a12</span><span class="p">))</span>

    <span class="c1"># Additional intermediate values</span>
    <span class="n">r_1_inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">r_1</span>
    <span class="n">product_r1_r2_c1</span> <span class="o">=</span> <span class="n">r_1</span> <span class="o">*</span> <span class="n">r_2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_1</span> <span class="o">/</span> <span class="n">freq_sample_inverse</span><span class="p">)</span>
    <span class="n">product_r2_r3_c2</span> <span class="o">=</span> <span class="n">r_2</span> <span class="o">*</span> <span class="n">r_3</span> <span class="o">*</span> <span class="p">(</span><span class="n">c_2</span> <span class="o">/</span> <span class="n">freq_sample_inverse</span><span class="p">)</span>

    <span class="c1"># Initialize the outputs and state of the equivalent circuit</span>
    <span class="n">nsamp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_db</span><span class="p">)</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span>
        <span class="n">reference_db</span>
    <span class="p">)</span>  <span class="c1"># Gain vector to apply to the BM motion, default is 1</span>
    <span class="n">output_db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">reference_db</span><span class="p">)</span>
    <span class="n">v_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">v_2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">small</span> <span class="o">=</span> <span class="mf">1e-30</span>

    <span class="c1"># Loop to process the envelope signal</span>
    <span class="c1"># The gain asymptote is 1 for an input envelope of 0 dB SPL</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamp</span><span class="p">):</span>
        <span class="n">v_0</span> <span class="o">=</span> <span class="n">reference_db</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">b_1</span> <span class="o">=</span> <span class="n">v_0</span> <span class="o">*</span> <span class="n">r_2</span> <span class="o">+</span> <span class="n">product_r1_r2_c1</span> <span class="o">*</span> <span class="n">v_1</span>
        <span class="n">b_2</span> <span class="o">=</span> <span class="n">product_r2_r3_c2</span> <span class="o">*</span> <span class="n">v_2</span>
        <span class="n">v_1</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">*</span> <span class="p">(</span><span class="n">a22</span> <span class="o">*</span> <span class="n">b_1</span> <span class="o">-</span> <span class="n">a12</span> <span class="o">*</span> <span class="n">b_2</span><span class="p">)</span>
        <span class="n">v_2</span> <span class="o">=</span> <span class="n">denom</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">a21</span> <span class="o">*</span> <span class="n">b_1</span> <span class="o">+</span> <span class="n">a11</span> <span class="o">*</span> <span class="n">b_2</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_0</span> <span class="o">-</span> <span class="n">v_1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r_1_inv</span>
        <span class="n">output_db</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>

    <span class="n">output_db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">output_db</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="p">(</span><span class="n">output_db</span> <span class="o">+</span> <span class="n">small</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">reference_db</span> <span class="o">+</span> <span class="n">small</span><span class="p">)</span>

    <span class="n">output_basilar_membrane</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">reference_basilar_membrane</span>

    <span class="k">return</span> <span class="n">output_db</span><span class="p">,</span> <span class="n">output_basilar_membrane</span></div>



<div class="viewcode-block" id="basilar_membrane_add_noise">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.basilar_membrane_add_noise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">basilar_membrane_add_noise</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">level1</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the IHC attenuation to the BM motion and to add a low-level Gaussian noise to</span>
<span class="sd">    give the auditory threshold.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (): BM motion to be attenuated</span>
<span class="sd">        threshold (): additive noise level in dB re:auditory threshold</span>
<span class="sd">        level1 (): an input having RMS=1 corresponds to Level1 dB SPL</span>

<span class="sd">    Returns:</span>
<span class="sd">        Attenuated signal with threshold noise added</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 19 June 2012.</span>
<span class="sd">        Just additive noise, 2 Oct 2012.</span>
<span class="sd">        Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">((</span><span class="n">threshold</span> <span class="o">-</span> <span class="n">level1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>  <span class="c1"># Linear gain for the noise</span>

    <span class="c1"># rng = np.random.default_rng()</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span>
        <span class="n">reference</span><span class="o">.</span><span class="n">shape</span>
    <span class="p">)</span>  <span class="c1"># Gaussian RMS=1, then attenuated</span>
    <span class="k">return</span> <span class="n">reference</span> <span class="o">+</span> <span class="n">noise</span></div>



<div class="viewcode-block" id="group_delay_compensate">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.group_delay_compensate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_delay_compensate</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">bandwidths</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">center_freq</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">freq_sample</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">ear_q</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">9.26449</span><span class="p">,</span>
    <span class="n">min_bandwidth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">24.7</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compensate for the group delay of the gammatone filter bank. The group</span>
<span class="sd">    delay is computed for each filter at its center frequency. The firing</span>
<span class="sd">    rate output of the IHC model is then adjusted so that all outputs have</span>
<span class="sd">    the same group delay.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        xenv (np.ndarray): matrix of signal envelopes or BM motion</span>
<span class="sd">        bandwidths (): gammatone filter bandwidths adjusted for loss</span>
<span class="sd">        center_freq (): center frequencies of the bands</span>
<span class="sd">        freq_sample (): sampling rate for the input signal in Hz (e.g. 24,000 Hz)</span>
<span class="sd">        ear_q (float):</span>
<span class="sd">        min_bandwidth (float) :</span>

<span class="sd">    Returns:</span>
<span class="sd">        processed (): envelopes or BM motion compensated for the group delay.</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 28 October 2011.</span>
<span class="sd">        Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Processing parameters</span>
    <span class="n">nchan</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bandwidths</span><span class="p">)</span>

    <span class="c1"># Filter ERB from Moore and Glasberg (1983)</span>
    <span class="n">erb</span> <span class="o">=</span> <span class="n">min_bandwidth</span> <span class="o">+</span> <span class="p">(</span><span class="n">center_freq</span> <span class="o">/</span> <span class="n">ear_q</span><span class="p">)</span>

    <span class="c1"># Initialize the gammatone filter coefficients</span>
    <span class="n">tpt</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">freq_sample</span>
    <span class="n">tpt_bandwidth</span> <span class="o">=</span> <span class="n">tpt</span> <span class="o">*</span> <span class="mf">1.019</span> <span class="o">*</span> <span class="n">bandwidths</span> <span class="o">*</span> <span class="n">erb</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tpt_bandwidth</span><span class="p">)</span>
    <span class="n">a_1</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">6.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_3</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_4</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">a_5</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>

    <span class="c1"># Compute the group delay in samples at fsamp for each filter</span>
    <span class="n">_group_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nchan</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchan</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_group_delay</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_delay</span><span class="p">(</span>
            <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_1</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">a_5</span><span class="p">[</span><span class="n">n</span><span class="p">]],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">a_1</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="o">-</span><span class="n">a_2</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="o">-</span><span class="n">a_3</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="o">-</span><span class="n">a_4</span><span class="p">[</span><span class="n">n</span><span class="p">]]),</span> <span class="mi">1</span>
        <span class="p">)</span>
    <span class="n">_group_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">_group_delay</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># convert to integer samples</span>

    <span class="c1"># Compute the delay correlation</span>
    <span class="n">group_delay_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_group_delay</span><span class="p">)</span>
    <span class="n">_group_delay</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">_group_delay</span> <span class="o">-</span> <span class="n">group_delay_min</span>
    <span class="p">)</span>  <span class="c1"># Remove the minimum delay from all the over values</span>
    <span class="n">group_delay_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_group_delay</span><span class="p">)</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">group_delay_max</span> <span class="o">-</span> <span class="n">_group_delay</span>
    <span class="p">)</span>  <span class="c1"># Samples delay needed to add to give alignment</span>

    <span class="c1"># Add delay correction to each frequency band</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">reference</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchan</span><span class="p">):</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="n">processed</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">correct</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="n">ref</span><span class="p">[:</span> <span class="n">npts</span> <span class="o">-</span> <span class="n">correct</span><span class="p">[</span><span class="n">n</span><span class="p">]]))</span>

    <span class="k">return</span> <span class="n">processed</span></div>



<div class="viewcode-block" id="convert_rms_to_sl">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.convert_rms_to_sl">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">convert_rms_to_sl</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">control</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">attenuated_ohc</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">threshold_low</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">compression_ratio</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">attenuated_ihc</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">|</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">level1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">threshold_high</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">small</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-30</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Covert the Root Mean Square average output of the gammatone filter bank</span>
<span class="sd">    into dB SL. The gain is linear below the lower threshold, compressive</span>
<span class="sd">    with a compression ratio of CR:1 between the lower and upper thresholds,</span>
<span class="sd">    and reverts to linear above the upper threshold. The compressor</span>
<span class="sd">    assumes that auditory threshold is 0 dB SPL.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (): analytic signal envelope (magnitude) returned by the</span>
<span class="sd">        gammatone filter bank, RMS average level</span>
<span class="sd">        control (): control signal envelope</span>
<span class="sd">        attenuated_ohc (): OHC attenuation at the input to the compressor</span>
<span class="sd">        threshold_low (): kneepoint for the low-level linear amplification</span>
<span class="sd">        compression_ratio (): compression ratio</span>
<span class="sd">        attenuated_ihc (): IHC attenuation at the input to the synapse</span>
<span class="sd">        level1 (): dB reference level: a signal having an RMS value of 1 is</span>
<span class="sd">                assigned to Level1 dB SPL.</span>
<span class="sd">        threshold_high (int):</span>
<span class="sd">        small (float):</span>

<span class="sd">    Returns:</span>
<span class="sd">        reference_db (): compressed output in dB above the impaired threshold</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 6 August 2007.</span>
<span class="sd">        Version for two-tone suppression, 29 August 2008.</span>
<span class="sd">        Translated from MATLAB to Python by Zuzanna Podwinska, March 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize the compression parameters</span>
    <span class="n">threshold_high</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Upper compression threshold</span>

    <span class="c1"># Convert the control to dB SPL</span>
    <span class="n">small</span> <span class="o">=</span> <span class="mf">1e-30</span>
    <span class="n">control_db_spl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">small</span><span class="p">)</span>
    <span class="n">control_db_spl</span> <span class="o">=</span> <span class="n">level1</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">control_db_spl</span><span class="p">)</span>
    <span class="n">control_db_spl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">control_db_spl</span><span class="p">,</span> <span class="n">threshold_high</span><span class="p">)</span>
    <span class="n">control_db_spl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">control_db_spl</span><span class="p">,</span> <span class="n">threshold_low</span><span class="p">)</span>

    <span class="c1"># Compute compression gain in dB</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="o">-</span><span class="n">attenuated_ohc</span> <span class="o">-</span> <span class="p">(</span><span class="n">control_db_spl</span> <span class="o">-</span> <span class="n">threshold_low</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">compression_ratio</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Convert the signal envelope to dB SPL</span>
    <span class="n">control_db_spl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">small</span><span class="p">)</span>
    <span class="n">control_db_spl</span> <span class="o">=</span> <span class="n">level1</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">control_db_spl</span><span class="p">)</span>
    <span class="n">control_db_spl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">control_db_spl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">reference_db</span> <span class="o">=</span> <span class="n">control_db_spl</span> <span class="o">+</span> <span class="n">gain</span> <span class="o">-</span> <span class="n">attenuated_ihc</span>
    <span class="n">reference_db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">reference_db</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reference_db</span></div>



<div class="viewcode-block" id="env_smooth">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.env_smooth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">env_smooth</span><span class="p">(</span><span class="n">envelopes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">segment_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to smooth the envelope returned by the cochlear model. The</span>
<span class="sd">    envelope is divided into segments having a 50% overlap. Each segment is</span>
<span class="sd">    windowed, summed, and divided by the window sum to produce the average.</span>
<span class="sd">    A raised cosine window is used. The envelope sub-sampling frequency is</span>
<span class="sd">    2*(1000/segsize).</span>

<span class="sd">    Arguments:</span>
<span class="sd">        envelopes (np.ndarray): matrix of envelopes in each of the auditory bands</span>
<span class="sd">        segment_size: averaging segment size in msec</span>
<span class="sd">        freq_sample (int): input envelope sampling rate in Hz</span>

<span class="sd">    Returns:</span>
<span class="sd">        smooth: matrix of subsampled windowed averages in each band</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 26 January 2007.</span>
<span class="sd">        Final half segment added 27 August 2012.</span>
<span class="sd">        Translated from MATLAB to Python by Gerardo Roa Dabike, September 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute the window</span>
    <span class="c1"># Segment size in samples</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">segment_size</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.001</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)))</span>
    <span class="n">n_samples</span> <span class="o">+=</span> <span class="n">n_samples</span> <span class="o">%</span> <span class="mi">2</span>

    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>  <span class="c1"># Raised cosine von Hann window</span>
    <span class="n">wsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>  <span class="c1"># Sum for normalization</span>

    <span class="c1">#  The first segment has a half window</span>
    <span class="n">nhalf</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">halfwindow</span> <span class="o">=</span> <span class="n">window</span><span class="p">[</span><span class="n">nhalf</span><span class="p">:</span><span class="n">n_samples</span><span class="p">]</span>
    <span class="n">halfsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">halfwindow</span><span class="p">)</span>

    <span class="c1"># Number of segments and assign the matrix storage</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">envelopes</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">envelopes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
        <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">npts</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">npts</span> <span class="o">-</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>

    <span class="c1">#  Loop to compute the envelope in each frequency band</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_channels</span><span class="p">):</span>
        <span class="c1"># Extract the envelope in the frequency band</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">envelopes</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># pylint: disable=invalid-name</span>

        <span class="c1"># The first (half) windowed segment</span>
        <span class="n">nstart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">smooth</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nhalf</span><span class="p">]</span> <span class="o">*</span> <span class="n">halfwindow</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="n">halfsum</span>

        <span class="c1"># Loop over the remaining full segments, 50% overlap</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nstart</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nstart</span> <span class="o">+</span> <span class="n">nhalf</span><span class="p">)</span>
            <span class="n">nstop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nstart</span> <span class="o">+</span> <span class="n">n_samples</span><span class="p">)</span>
            <span class="n">smooth</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nstop</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="n">wsum</span>

        <span class="c1"># The last (half) windowed segment</span>
        <span class="n">nstart</span> <span class="o">=</span> <span class="n">nstart</span> <span class="o">+</span> <span class="n">nhalf</span>
        <span class="n">nstop</span> <span class="o">=</span> <span class="n">nstart</span> <span class="o">+</span> <span class="n">nhalf</span>
        <span class="n">smooth</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nstop</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span><span class="p">[:</span><span class="n">nhalf</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="n">halfsum</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">smooth</span></div>



<div class="viewcode-block" id="mel_cepstrum_correlation">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.mel_cepstrum_correlation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mel_cepstrum_correlation</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">distorted</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">addnoise</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-correlations between the input signal time-frequency</span>
<span class="sd">    envelope and the distortion time-frequency envelope.</span>

<span class="sd">    For each time interval, the log spectrum is fitted with a set of</span>
<span class="sd">    half-cosine basis functions. The spectrum weighted by the basis</span>
<span class="sd">    functions corresponds to Mel Cepstral Coefficients computed in the</span>
<span class="sd">    frequency domain. The amplitude-normalized cross-covariance between</span>
<span class="sd">    the time-varying basis functions for the input and output signals is</span>
<span class="sd">    then computed.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (): subsampled input signal envelope in dB SL in each critical band</span>
<span class="sd">        distorted (): subsampled distorted output signal envelope</span>
<span class="sd">        threshold (): threshold in dB SPL to include segment in calculation</span>
<span class="sd">        addnoise (): additive Gaussian noise to ensure 0 cross-corr at low levels</span>

<span class="sd">    Returns:</span>
<span class="sd">        average_cepstral_correlation : average cepstral correlation 2-6, input vs output</span>
<span class="sd">        individual_cepstral_correlations : individual cepstral correlations,</span>
<span class="sd">            input vs output</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 24 October 2006.</span>
<span class="sd">        Difference signal removed for cochlear model, 31 January 2007.</span>
<span class="sd">        Absolute value added 13 May 2011.</span>
<span class="sd">        Changed to loudness criterion for silence threshsold, 28 August 2012.</span>
<span class="sd">        Translated from MATLAB to Python by Gerardo Roa Dabike, September 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Processing parameters</span>
    <span class="n">nbands</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Mel cepstrum basis functions (mel cepstrum because of auditory bands)</span>
    <span class="n">nbasis</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># Number of cepstral coefficients to be used</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbasis</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbands</span><span class="p">)</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nbands</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mel_cepstral</span> <span class="o">=</span> <span class="n">basis</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Find the segments that lie sufficiently above the quiescent rate</span>
    <span class="n">reference_linear</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span>
        <span class="n">reference</span> <span class="o">/</span> <span class="mi">20</span>
    <span class="p">)</span>  <span class="c1"># Convert envelope dB to linear (specific loudness)</span>
    <span class="n">xsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_linear</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">nbands</span>  <span class="c1"># Proportional to loudness in sones</span>
    <span class="n">xsum</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">xsum</span><span class="p">)</span>  <span class="c1"># Convert back to dB (loudness in phons)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xsum</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Identify those segments above threshold</span>
    <span class="n">nsamp</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Number of segments above threshold</span>

    <span class="c1"># Exit if not enough segments above zero</span>
    <span class="n">average_cepstral_correlation</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">individual_cepstral_correlations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbasis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nsamp</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Function MelCepstrumCorrelation: Signal below threshold, outputs set to 0.&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">average_cepstral_correlation</span><span class="p">,</span> <span class="n">individual_cepstral_correlations</span>

    <span class="c1"># Remove the silent intervals</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">distorted</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>

    <span class="c1"># Add the low-level noise to the envelopes</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">+</span> <span class="n">addnoise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">proc</span> <span class="o">+</span> <span class="n">addnoise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Compute the mel cepstrum coefficients using only those segments</span>
    <span class="c1"># above threshold</span>

    <span class="n">reference_cep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mel_cepstral</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
    <span class="n">processed_cep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mel_cepstral</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">proc</span><span class="p">)</span>

    <span class="c1"># Remove the average value from the cepstral coefficients. The</span>
    <span class="c1"># cross-correlation thus becomes a cross-covariance, and there</span>
    <span class="c1"># is no effect of the absolute signal level in dB.</span>
    <span class="n">reference_cep</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_cep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">processed_cep</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">processed_cep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Normalized cross-correlations between the time-varying cepstral coeff</span>
    <span class="c1"># individual_cepstral_correlations = np.zeros(nbasis)  # Input vs output</span>
    <span class="n">small</span> <span class="o">=</span> <span class="mf">1.0e-30</span>
    <span class="n">xsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_cep</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ysum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">processed_cep</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">xsum</span> <span class="o">&lt;</span> <span class="n">small</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ysum</span> <span class="o">&lt;</span> <span class="n">small</span><span class="p">)</span>
    <span class="n">individual_cepstral_correlations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbasis</span><span class="p">)</span>
    <span class="n">individual_cepstral_correlations</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_cep</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">processed_cep</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xsum</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">ysum</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># Figure of merit is the average of the cepstral correlations, ignoring</span>
    <span class="c1"># the first (average spectrum level).</span>
    <span class="n">average_cepstral_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">individual_cepstral_correlations</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nbasis</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbasis</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">average_cepstral_correlation</span><span class="p">,</span> <span class="n">individual_cepstral_correlations</span></div>



<div class="viewcode-block" id="melcor9">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.melcor9">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">melcor9</span><span class="p">(</span>
    <span class="n">reference</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">distorted</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">add_noise</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">segment_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n_cepstral_coef</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-correlations between the input signal</span>
<span class="sd">    time-frequency envelope and the distortion time-frequency envelope. For</span>
<span class="sd">    each time interval, the log spectrum is fitted with a set of half-cosine</span>
<span class="sd">    basis functions. The spectrum weighted by the basis functions corresponds</span>
<span class="sd">    to mel cepstral coefficients computed in the frequency domain. The</span>
<span class="sd">    amplitude-normalized cross-covariance between the time-varying basis</span>
<span class="sd">    functions for the input and output signals is then computed for each of</span>
<span class="sd">    the 8 modulation frequencies.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference (): subsampled input signal envelope in dB SL in each critical band</span>
<span class="sd">        distorted (): subsampled distorted output signal envelope</span>
<span class="sd">        threshold (): threshold in dB SPL to include segment in calculation</span>
<span class="sd">        add_noise (): additive Gaussian noise to ensure 0 cross-corr at low levels</span>
<span class="sd">        segment_size (): segment size in ms used for the envelope LP filter (8 msec)</span>
<span class="sd">        n_cepstral_coef (int): Number of cepstral coefficients</span>

<span class="sd">    Returns:</span>
<span class="sd">        mel_cepstral_average (): average of the modulation correlations across analysis</span>
<span class="sd">            frequency bands and modulation frequency bands, basis functions 2 -6</span>
<span class="sd">        mel_cepstral_low (): average over the four lower mod freq bands, 0 - 20 Hz</span>
<span class="sd">        mel_cepstral_high (): average over the four higher mod freq bands, 20 - 125 Hz</span>
<span class="sd">        mel_cepstral_modulation (): vector of cross-correlations by modulation</span>
<span class="sd">            frequency, averaged over analysis frequency band</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 24 October 2006.</span>
<span class="sd">        Difference signal removed for cochlear model, 31 January 2007.</span>
<span class="sd">        Absolute value added 13 May 2011.</span>
<span class="sd">        Changed to loudness criterion for silence threshold, 28 August 2012.</span>
<span class="sd">        Version using envelope modulation filters, 15 July 2014.</span>
<span class="sd">        Modulation frequency vector output added 27 August 2014.</span>
<span class="sd">        Translated from MATLAB to Python by Gerardo Roa Dabike, September 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Processing parameters</span>
    <span class="n">nbands</span> <span class="o">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Mel cepstrum basis functions (mel cepstrum because of auditory bands)</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_cepstral_coef</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbands</span><span class="p">)</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">nbands</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">cepm</span> <span class="o">=</span> <span class="n">basis</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Find the segments that lie sufficiently above the quiescent rate</span>
    <span class="c1"># Convert envelope dB to linear (specific loudness)</span>
    <span class="n">reference_linear</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">reference</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>

    <span class="c1"># Proportional to loudness in sones</span>
    <span class="n">reference_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_linear</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">nbands</span>

    <span class="c1"># Convert back to dB (loudness in phons)</span>
    <span class="n">reference_sum</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">reference_sum</span><span class="p">)</span>

    <span class="c1"># Identify those segments above threshold</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">reference_sum</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">segments_above_threshold</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Number of segments above threshold</span>

    <span class="c1"># Modulation filter bands, segment size is 8 msec</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">12.5</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">32.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">80.0</span><span class="p">]</span>  <span class="c1"># 8 bands covering 0 to 125 Hz</span>
    <span class="n">n_modulation_filter_bands</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>  <span class="c1"># Number of modulation filter bands</span>

    <span class="c1"># Exit if not enough segments above zero</span>
    <span class="n">mel_cepstral_average</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">mel_cepstral_low</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">mel_cepstral_high</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">mel_cepstral_modulation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_modulation_filter_bands</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">segments_above_threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Function melcor9: Signal below threshold, outputs set to 0.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">mel_cepstral_average</span><span class="p">,</span>
            <span class="n">mel_cepstral_low</span><span class="p">,</span>
            <span class="n">mel_cepstral_high</span><span class="p">,</span>
            <span class="n">mel_cepstral_modulation</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Remove the silent intervals</span>
    <span class="n">_reference</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
    <span class="n">_distorted</span> <span class="o">=</span> <span class="n">distorted</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>

    <span class="c1"># Add the low-level noise to the envelopes</span>
    <span class="n">_reference</span> <span class="o">+=</span> <span class="n">add_noise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">_reference</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">_distorted</span> <span class="o">+=</span> <span class="n">add_noise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">_distorted</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Compute the mel cepstrum coefficients using only those segments</span>
    <span class="c1"># above threshold</span>
    <span class="n">reference_cep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cepm</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">_reference</span><span class="p">[:,</span> <span class="p">:</span><span class="n">segments_above_threshold</span><span class="p">])</span>
    <span class="n">distorted_cep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cepm</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">_distorted</span><span class="p">[:,</span> <span class="p">:</span><span class="n">segments_above_threshold</span><span class="p">])</span>

    <span class="n">reference_cep</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_cep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">distorted_cep</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distorted_cep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Envelope sampling parameters</span>
    <span class="n">sampling_freq</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">segment_size</span><span class="p">)</span>  <span class="c1"># Envelope sampling frequency in Hz</span>
    <span class="n">nyquist_freq</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sampling_freq</span>  <span class="c1"># Envelope Nyquist frequency</span>

    <span class="c1"># Design the linear-phase envelope modulation filters</span>
    <span class="n">n_fir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span>
        <span class="mi">128</span> <span class="o">*</span> <span class="p">(</span><span class="n">nyquist_freq</span> <span class="o">/</span> <span class="mi">125</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># Adjust filter length to sampling rate</span>
    <span class="n">n_fir</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n_fir</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># Force an even filter length</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_modulation_filter_bands</span><span class="p">,</span> <span class="n">n_fir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># LP filter 0-4 Hz</span>
    <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span>
        <span class="n">n_fir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">nyquist_freq</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span> <span class="n">pass_zero</span><span class="o">=</span><span class="s2">&quot;lowpass&quot;</span>
    <span class="p">)</span>
    <span class="c1"># HP 80-125 Hz</span>
    <span class="n">b</span><span class="p">[</span><span class="n">n_modulation_filter_bands</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span>
        <span class="n">n_fir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">edge</span><span class="p">[</span><span class="n">n_modulation_filter_bands</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">nyquist_freq</span><span class="p">,</span>
        <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
        <span class="n">pass_zero</span><span class="o">=</span><span class="s2">&quot;highpass&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Bandpass filter</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_modulation_filter_bands</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span>
            <span class="n">n_fir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">nyquist_freq</span><span class="p">,</span> <span class="n">edge</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">nyquist_freq</span><span class="p">],</span>
            <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hann&quot;</span><span class="p">,</span>
            <span class="n">pass_zero</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">mel_cepstral_cross_covar</span> <span class="o">=</span> <span class="n">melcor9_crosscovmatrix</span><span class="p">(</span>
        <span class="n">b</span><span class="p">,</span>
        <span class="n">n_modulation_filter_bands</span><span class="p">,</span>
        <span class="n">n_cepstral_coef</span><span class="p">,</span>
        <span class="n">segments_above_threshold</span><span class="p">,</span>
        <span class="n">n_fir</span><span class="p">,</span>
        <span class="n">reference_cep</span><span class="p">,</span>
        <span class="n">distorted_cep</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">mel_cepstral_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mel_cepstral_cross_covar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">mel_cepstral_average</span> <span class="o">/=</span> <span class="n">n_modulation_filter_bands</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_cepstral_coef</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">mel_cepstral_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mel_cepstral_cross_covar</span><span class="p">[:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">mel_cepstral_low</span> <span class="o">/=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_cepstral_coef</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">mel_cepstral_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mel_cepstral_cross_covar</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">mel_cepstral_high</span> <span class="o">/=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_cepstral_coef</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">mel_cepstral_modulation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mel_cepstral_cross_covar</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">mel_cepstral_average</span><span class="p">,</span>
        <span class="n">mel_cepstral_low</span><span class="p">,</span>
        <span class="n">mel_cepstral_high</span><span class="p">,</span>
        <span class="n">mel_cepstral_modulation</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="melcor9_crosscovmatrix">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.melcor9_crosscovmatrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">melcor9_crosscovmatrix</span><span class="p">(</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">nmod</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nbasis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nsamp</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nfir</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">reference_cep</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">processed_cep</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the cross-covariance matrix.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        b (): ???</span>
<span class="sd">        nmod (): ???</span>
<span class="sd">        nbasis (): ???</span>
<span class="sd">        nsamp (): ???</span>
<span class="sd">        nfir (): ???</span>
<span class="sd">        xcep (): ???</span>
<span class="sd">        ycep (): ???</span>

<span class="sd">    Returns:</span>
<span class="sd">        cross_covariance_matrix ():</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">small</span> <span class="o">=</span> <span class="mf">1.0e-30</span>
    <span class="n">nfir2</span> <span class="o">=</span> <span class="n">nfir</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># Convolve the input and output envelopes with the modulation filters</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmod</span><span class="p">,</span> <span class="n">nbasis</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmod</span><span class="p">,</span> <span class="n">nbasis</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmod</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbasis</span><span class="p">):</span>
            <span class="c1"># Convolve and remove transients</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">reference_cep</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>
            <span class="n">reference</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nfir2</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">nfir2</span> <span class="o">+</span> <span class="n">nsamp</span><span class="p">)]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">processed_cep</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>
            <span class="n">processed</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">nfir2</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">nfir2</span> <span class="o">+</span> <span class="n">nsamp</span><span class="p">)]</span>

    <span class="c1"># Compute the cross-covariance matrix</span>
    <span class="n">cross_covariance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmod</span><span class="p">,</span> <span class="n">nbasis</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmod</span><span class="p">):</span>
        <span class="c1"># Input freq band j, modulation freq m</span>
        <span class="n">x_j</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">x_j</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">reference_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x_j</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Processed signal band</span>
        <span class="n">y_j</span> <span class="o">=</span> <span class="n">processed</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="n">y_j</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">processed_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_j</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x_j</span> <span class="o">*</span> <span class="n">y_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">reference_sum</span> <span class="o">&lt;</span> <span class="n">small</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">processed_sum</span> <span class="o">&lt;</span> <span class="n">small</span><span class="p">)</span>
        <span class="n">cross_covariance_matrix</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xy</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">reference_sum</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">processed_sum</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">cross_covariance_matrix</span></div>



<div class="viewcode-block" id="spectrum_diff">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.spectrum_diff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spectrum_diff</span><span class="p">(</span>
    <span class="n">reference_sl</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">processed_sl</span><span class="p">:</span> <span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute changes in the long-term spectrum and spectral slope.</span>

<span class="sd">    The metric is based on the spectral distortion metric of Moore and Tan[1]_</span>
<span class="sd">    (JAES, Vol 52, pp 900-914). The log envelopes in dB SL are converted to</span>
<span class="sd">    linear to approximate specific loudness. The outputs are the sum of the</span>
<span class="sd">    absolute differences, the standard deviation of the differences, and the</span>
<span class="sd">    maximum absolute difference. The same three outputs are provided for the</span>
<span class="sd">    normalized spectral difference and for the slope. The output is</span>
<span class="sd">    calibrated so that a processed signal having 0 amplitude produces a</span>
<span class="sd">    value of 1 for the spectrum difference.</span>

<span class="sd">    Abs diff: weight all deviations uniformly</span>
<span class="sd">    Std diff: weight larger deviations more than smaller deviations</span>
<span class="sd">    Max diff: only weight the largest deviation</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference_sl (np.ndarray): reference signal spectrum in dB SL</span>
<span class="sd">        processed_sl (np.ndarray): degraded signal spectrum in dB SL</span>

<span class="sd">    Returns:</span>
<span class="sd">        dloud (np.array) : [sum abs diff, std dev diff, max diff] spectra</span>
<span class="sd">        dnorm (np.array) : [sum abs diff, std dev diff, max diff] norm spectra</span>
<span class="sd">        dslope (np.array) : [sum abs diff, std dev diff, max diff] slope</span>

<span class="sd">    References:</span>
<span class="sd">    .. [1] Moore BCJ, Tan, CT (2004) Development and Validation of a Method</span>
<span class="sd">           for Predicting the Perceived Naturalness of Sounds Subjected to</span>
<span class="sd">           Spectral Distortion J Audio Eng Soc 52(9):900-914. Available at.</span>
<span class="sd">           &lt;http://www.aes.org/e-lib/browse.cfm?elib=13018&gt;.</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 28 June 2012.</span>
<span class="sd">        Translated from MATLAB to Python by Gerardo Roa Dabike, September 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert the dB SL to linear magnitude values. Because of the auditory</span>
    <span class="c1"># filter bank, the OHC compression, and auditory threshold, the linear</span>
    <span class="c1"># values are closely related to specific loudness.</span>
    <span class="n">nbands</span> <span class="o">=</span> <span class="n">reference_sl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reference_linear_magnitude</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">reference_sl</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">processed_linear_magnitude</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">processed_sl</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>

    <span class="c1"># Normalize the level of the reference and degraded signals to have the</span>
    <span class="c1"># same loudness. Thus overall level is ignored while differences in</span>
    <span class="c1"># spectral shape are measured.</span>
    <span class="n">reference_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_linear_magnitude</span><span class="p">)</span>
    <span class="n">reference_linear_magnitude</span> <span class="o">/=</span> <span class="p">(</span>
        <span class="n">reference_sum</span>  <span class="c1"># Loudness sum = 1 (arbitrary amplitude, proportional to sones)</span>
    <span class="p">)</span>
    <span class="n">processed_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">processed_linear_magnitude</span><span class="p">)</span>
    <span class="n">processed_linear_magnitude</span> <span class="o">/=</span> <span class="n">processed_sum</span>

    <span class="c1"># Compute the spectrum difference</span>
    <span class="n">dloud</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">diff_spectrum</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">reference_linear_magnitude</span> <span class="o">-</span> <span class="n">processed_linear_magnitude</span>
    <span class="p">)</span>  <span class="c1"># Difference in specific loudness in each band</span>
    <span class="n">dloud</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_spectrum</span><span class="p">))</span>
    <span class="n">dloud</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbands</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff_spectrum</span><span class="p">)</span>  <span class="c1"># Biased std: second moment</span>
    <span class="n">dloud</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_spectrum</span><span class="p">))</span>

    <span class="c1"># Compute the normalized spectrum difference</span>
    <span class="n">dnorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">diff_normalised_spectrum</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">reference_linear_magnitude</span> <span class="o">-</span> <span class="n">processed_linear_magnitude</span>
    <span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
        <span class="n">reference_linear_magnitude</span> <span class="o">+</span> <span class="n">processed_linear_magnitude</span>
    <span class="p">)</span>  <span class="c1"># Relative difference in specific loudness</span>
    <span class="n">dnorm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_normalised_spectrum</span><span class="p">))</span>
    <span class="n">dnorm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbands</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff_normalised_spectrum</span><span class="p">)</span>
    <span class="n">dnorm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_normalised_spectrum</span><span class="p">))</span>

    <span class="c1"># Compute the slope difference</span>
    <span class="n">dslope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">reference_slope</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">reference_linear_magnitude</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nbands</span><span class="p">]</span>
        <span class="o">-</span> <span class="n">reference_linear_magnitude</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">nbands</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">processed_slope</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">processed_linear_magnitude</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">nbands</span><span class="p">]</span>
        <span class="o">-</span> <span class="n">processed_linear_magnitude</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">nbands</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">diff_slope</span> <span class="o">=</span> <span class="n">reference_slope</span> <span class="o">-</span> <span class="n">processed_slope</span>  <span class="c1"># Slope difference</span>
    <span class="n">dslope</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_slope</span><span class="p">))</span>
    <span class="n">dslope</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbands</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff_slope</span><span class="p">)</span>
    <span class="n">dslope</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff_slope</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">dloud</span><span class="p">,</span> <span class="n">dnorm</span><span class="p">,</span> <span class="n">dslope</span></div>



<div class="viewcode-block" id="bm_covary">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.bm_covary">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">bm_covary</span><span class="p">(</span>
    <span class="n">reference_basilar_membrane</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">processed_basilar_membrane</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">segment_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-covariance (normalized cross-correlation) between  the reference</span>
<span class="sd">    and processed signals in each auditory band. The signals are divided into segments</span>
<span class="sd">    having 50% overlap.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        reference_basilar_membrane (): Basilar Membrane movement, reference signal</span>
<span class="sd">        processed_basilar_membrane (): Basilar Membrane movement, processed signal</span>
<span class="sd">        segment_size (): signal segment size, msec</span>
<span class="sd">        freq_sample (int): sampling rate in Hz</span>

<span class="sd">    Returns:</span>
<span class="sd">        signal_cross_covariance (np.array) : [nchan,nseg] of cross-covariance values</span>
<span class="sd">        reference_mean_square (np.array) : [nchan,nseg] of MS input signal energy values</span>
<span class="sd">        processed_mean_square (np.array) : [nchan,nseg] of MS processed signal energy</span>
<span class="sd">            values</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 28 August 2012.</span>
<span class="sd">        Output amplitude adjustment added, 30 october 2012.</span>
<span class="sd">        Translated from MATLAB to Python by Gerardo Roa Dabike, September 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Initialize parameters</span>
    <span class="n">small</span> <span class="o">=</span> <span class="mf">1.0e-30</span>

    <span class="c1"># Lag for computing the cross-covariance</span>
    <span class="n">lagsize</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Lag (+/-) in msec</span>
    <span class="n">maxlag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">lagsize</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.001</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">))</span>  <span class="c1"># Lag in samples</span>

    <span class="c1"># Compute the segment size in samples</span>
    <span class="n">nwin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">segment_size</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.001</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)))</span>

    <span class="n">nwin</span> <span class="o">+=</span> <span class="n">nwin</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># Force window length to be even</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">nwin</span><span class="p">)</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>  <span class="c1"># Raised cosine von Hann window</span>

    <span class="c1"># compute inverted Window autocorrelation</span>
    <span class="n">win_corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
    <span class="n">start_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlag</span><span class="p">)</span>
    <span class="n">end_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">start_sample</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;segment size too small&quot;</span><span class="p">)</span>
    <span class="n">win_corr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">win_corr</span><span class="p">[</span><span class="n">start_sample</span><span class="p">:</span><span class="n">end_sample</span><span class="p">]</span>
    <span class="n">win_sum2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">window</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Window power, inverted</span>

    <span class="c1"># The first segment has a half window</span>
    <span class="n">nhalf</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nwin</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">half_window</span> <span class="o">=</span> <span class="n">window</span><span class="p">[</span><span class="n">nhalf</span><span class="p">:</span><span class="n">nwin</span><span class="p">]</span>
    <span class="n">half_corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">half_window</span><span class="p">,</span> <span class="n">half_window</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
    <span class="n">start_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">half_window</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlag</span><span class="p">)</span>
    <span class="n">end_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">half_window</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">start_sample</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;segment size too small&quot;</span><span class="p">)</span>
    <span class="n">half_corr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">half_corr</span><span class="p">[</span><span class="n">start_sample</span><span class="p">:</span><span class="n">end_sample</span><span class="p">]</span>
    <span class="n">halfsum2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">half_window</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># MS sum normalization, first segment</span>

    <span class="c1"># Number of segments</span>
    <span class="n">nchan</span> <span class="o">=</span> <span class="n">reference_basilar_membrane</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="n">reference_basilar_membrane</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">npts</span> <span class="o">/</span> <span class="n">nwin</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">npts</span> <span class="o">-</span> <span class="n">nwin</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">nwin</span><span class="p">))</span>

    <span class="n">reference_mean_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
    <span class="n">processed_mean_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
    <span class="n">signal_cross_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nchan</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>

    <span class="c1"># Loop to compute the signal mean-squared level in each band for each</span>
    <span class="c1"># segment and to compute the cross-corvariances.</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchan</span><span class="p">):</span>
        <span class="c1"># Extract the BM motion in the frequency band</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">reference_basilar_membrane</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">processed_basilar_membrane</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># The first (half) windowed segment</span>
        <span class="n">nstart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">reference_seg</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nhalf</span><span class="p">]</span> <span class="o">*</span> <span class="n">half_window</span>  <span class="c1"># Window the reference</span>
        <span class="n">processed_seg</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nhalf</span><span class="p">]</span> <span class="o">*</span> <span class="n">half_window</span>  <span class="c1"># Window the processed signal</span>
        <span class="n">reference_seg</span> <span class="o">=</span> <span class="n">reference_seg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">)</span>  <span class="c1"># Make 0-mean</span>
        <span class="n">processed_seg</span> <span class="o">=</span> <span class="n">processed_seg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">processed_seg</span><span class="p">)</span>

        <span class="c1"># Normalize signal MS value by the window</span>
        <span class="n">ref_mean_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_seg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">halfsum2</span>

        <span class="n">proc_mean_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">processed_seg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">halfsum2</span>
        <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">,</span> <span class="n">processed_seg</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
        <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlation</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlag</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">unbiased_cross_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">correlation</span> <span class="o">*</span> <span class="n">half_corr</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref_mean_square</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">proc_mean_squared</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">):</span>
            <span class="c1"># Normalize cross-covariance</span>
            <span class="n">signal_cross_covariance</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">unbiased_cross_correlation</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">ref_mean_square</span> <span class="o">*</span> <span class="n">proc_mean_squared</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal_cross_covariance</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Save the reference MS level</span>
        <span class="n">reference_mean_square</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_mean_square</span>
        <span class="n">processed_mean_square</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc_mean_squared</span>

        <span class="c1"># Loop over the remaining full segments, 50% overlap</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nstart</span> <span class="o">=</span> <span class="n">nstart</span> <span class="o">+</span> <span class="n">nhalf</span>
            <span class="n">nstop</span> <span class="o">=</span> <span class="n">nstart</span> <span class="o">+</span> <span class="n">nwin</span>
            <span class="n">reference_seg</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nstop</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span>  <span class="c1"># Window the reference</span>
            <span class="n">processed_seg</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nstop</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span>  <span class="c1"># Window the processed signal</span>
            <span class="n">reference_seg</span> <span class="o">=</span> <span class="n">reference_seg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">)</span>  <span class="c1"># Make 0-mean</span>
            <span class="n">processed_seg</span> <span class="o">=</span> <span class="n">processed_seg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">processed_seg</span><span class="p">)</span>

            <span class="c1"># Normalize signal MS value by the window</span>
            <span class="n">ref_mean_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_seg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">win_sum2</span>
            <span class="n">proc_mean_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">processed_seg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">win_sum2</span>
            <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">,</span> <span class="n">processed_seg</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
            <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlation</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlag</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">))</span>
            <span class="p">]</span>

            <span class="n">unbiased_cross_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">correlation</span> <span class="o">*</span> <span class="n">win_corr</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ref_mean_square</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">proc_mean_squared</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">):</span>
                <span class="c1"># Normalize cross-covariance</span>
                <span class="n">signal_cross_covariance</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">unbiased_cross_correlation</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">ref_mean_square</span> <span class="o">*</span> <span class="n">proc_mean_squared</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal_cross_covariance</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">reference_mean_square</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_mean_square</span>
            <span class="n">processed_mean_square</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc_mean_squared</span>

        <span class="c1"># The last (half) windowed segment</span>
        <span class="n">nstart</span> <span class="o">=</span> <span class="n">nstart</span> <span class="o">+</span> <span class="n">nhalf</span>
        <span class="n">nstop</span> <span class="o">=</span> <span class="n">nstart</span> <span class="o">+</span> <span class="n">nhalf</span>
        <span class="n">reference_seg</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nstop</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nhalf</span><span class="p">]</span>  <span class="c1"># Window the reference</span>
        <span class="n">processed_seg</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">nstart</span><span class="p">:</span><span class="n">nstop</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nhalf</span><span class="p">]</span>  <span class="c1"># Window the processed signal</span>
        <span class="n">reference_seg</span> <span class="o">=</span> <span class="n">reference_seg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">)</span>  <span class="c1"># Make 0-mean</span>
        <span class="n">processed_seg</span> <span class="o">=</span> <span class="n">processed_seg</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">processed_seg</span><span class="p">)</span>
        <span class="c1"># Normalize signal MS value by the window</span>
        <span class="n">ref_mean_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">reference_seg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">halfsum2</span>
        <span class="n">proc_mean_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">processed_seg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">halfsum2</span>

        <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">,</span> <span class="n">processed_seg</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
        <span class="n">correlation</span> <span class="o">=</span> <span class="n">correlation</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlag</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_seg</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="n">unbiased_cross_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">correlation</span> <span class="o">*</span> <span class="n">half_corr</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ref_mean_square</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">proc_mean_squared</span> <span class="o">&gt;</span> <span class="n">small</span><span class="p">):</span>
            <span class="c1"># Normalized cross-covariance</span>
            <span class="n">signal_cross_covariance</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">unbiased_cross_correlation</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">ref_mean_square</span> <span class="o">*</span> <span class="n">proc_mean_squared</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">signal_cross_covariance</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Save the reference and processed MS level</span>
        <span class="n">reference_mean_square</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_mean_square</span>
        <span class="n">processed_mean_square</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">proc_mean_squared</span>

    <span class="c1"># Limit the cross-covariance to lie between 0 and 1</span>
    <span class="n">signal_cross_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">signal_cross_covariance</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Adjust the BM magnitude to correspond to the envelope in dB SL</span>
    <span class="n">reference_mean_square</span> <span class="o">*=</span> <span class="mf">2.0</span>
    <span class="n">processed_mean_square</span> <span class="o">*=</span> <span class="mf">2.0</span>

    <span class="k">return</span> <span class="n">signal_cross_covariance</span><span class="p">,</span> <span class="n">reference_mean_square</span><span class="p">,</span> <span class="n">processed_mean_square</span></div>



<div class="viewcode-block" id="ave_covary2">
<a class="viewcode-back" href="../../../../clarity.evaluator.haspi.html#clarity.evaluator.haspi.eb.ave_covary2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ave_covary2</span><span class="p">(</span>
    <span class="n">signal_cross_covariance</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">reference_signal_mean_square</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">threshold_db</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">lp_filter_order</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">freq_cutoff</span><span class="p">:</span> <span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the average cross-covariance between the reference and processed</span>
<span class="sd">    signals in each auditory band.</span>

<span class="sd">    The silent time-frequency tiles are removed from consideration. The</span>
<span class="sd">    cross-covariance is computed for each segment in each frequency band. The</span>
<span class="sd">    values are weighted by 1 for inclusion or 0 if the tile is below</span>
<span class="sd">    threshold. The sum of the covariance values across time and frequency are</span>
<span class="sd">    then divided by the total number of tiles above threshold. The calculation</span>
<span class="sd">    is a modification of Tan et al.[1]_ . The cross-covariance is also output</span>
<span class="sd">    with a frequency weighting that reflects the loss of IHC synchronization at high</span>
<span class="sd">    frequencies Johnson[2]_.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        signal_cross_covariance (np.array): [nchan,nseg] of cross-covariance values</span>
<span class="sd">        reference_signal_mean_square (np.array): [nchan,nseg] of reference signal MS</span>
<span class="sd">            values</span>
<span class="sd">        threshold_db (): threshold in dB SL to include segment ave over freq in</span>
<span class="sd">            average</span>
<span class="sd">        lp_filter (list): LP filter order</span>
<span class="sd">        freq_cutoff (list): Cutoff frequencies in Hz</span>

<span class="sd">    Returns:</span>
<span class="sd">        average_covariance (): cross-covariance in segments averaged over time and</span>
<span class="sd">            frequency</span>
<span class="sd">        ihc_sync_covariance (): cross-covariance array, 6 different weightings for loss</span>
<span class="sd">            of IHC synchronization at high frequencies:</span>
<span class="sd">              LP Filter Order     Cutoff Freq, kHz</span>
<span class="sd">                1              1.5</span>
<span class="sd">                3              2.0</span>
<span class="sd">                5              2.5, 3.0, 3.5, 4.0</span>

<span class="sd">    References:</span>

<span class="sd">    .. [1] Tan CT, Moore, BCJ, Zacharov N, Mattila VV (2004) Predicting the Perceived</span>
<span class="sd">           Quality of Nonlinearly Distorted Music and Speech Signals. J Audio Eng Soc</span>
<span class="sd">           52(9):900-914. Available at.</span>
<span class="sd">           &lt;http://www.aes.org/e-lib/browse.cfm?elib=13013&gt;.</span>

<span class="sd">    .. [2] Johnson DH (1980) The relationship between spike rate and synchrony in</span>
<span class="sd">           responses of auditory‐nerve fibers to single tones J Acoustical Soc of Am</span>
<span class="sd">           68:1115 Available at.</span>
<span class="sd">           &lt;https://doi.org/10.1121/1.384982&gt;</span>

<span class="sd">    Updates:</span>
<span class="sd">        James M. Kates, 28 August 2012.</span>
<span class="sd">        Adjusted for BM vibration in dB SL, 30 October 2012.</span>
<span class="sd">        Threshold for including time-freq tile modified, 30 January 2013.</span>
<span class="sd">        Version for different sync loss, 15 February 2013.</span>
<span class="sd">        Translated from MATLAB to Python by Gerardo Roa Dabike, September 2022.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Array dimensions</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="n">signal_cross_covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Initialize the LP filter for loss of IHC synchronization</span>
    <span class="c1"># Center frequencies in Hz on an ERB scale</span>
    <span class="n">_center_freq</span> <span class="o">=</span> <span class="n">center_frequency</span><span class="p">(</span><span class="n">n_channels</span><span class="p">)</span>
    <span class="c1"># Default LP filter order</span>
    <span class="k">if</span> <span class="n">lp_filter_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lp_filter_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
    <span class="c1"># Default cutoff frequencies in Hz</span>
    <span class="k">if</span> <span class="n">freq_cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">freq_cutoff</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">])</span>

    <span class="n">fc2p</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">freq_cutoff</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lp_filter_order</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>
    <span class="n">freq2p</span> <span class="o">=</span> <span class="n">_center_freq</span> <span class="o">**</span> <span class="p">(</span>
        <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">lp_filter_order</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>
    <span class="n">fsync</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fc2p</span> <span class="o">/</span> <span class="p">(</span><span class="n">fc2p</span> <span class="o">+</span> <span class="n">freq2p</span><span class="p">))</span>

    <span class="c1"># Find the segments that lie sufficiently above the threshold.</span>
    <span class="c1"># Convert squared amplitude to dB envelope</span>
    <span class="n">signal_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">reference_signal_mean_square</span><span class="p">)</span>
    <span class="c1"># Linear amplitude (specific loudness)</span>
    <span class="n">signal_linear_amplitude</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">signal_rms</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
    <span class="c1"># Intensity averaged over frequency bands</span>
    <span class="n">reference_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal_linear_amplitude</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_channels</span>
    <span class="c1"># Convert back to dB (loudness in phons)</span>
    <span class="n">reference_mean</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">reference_mean</span><span class="p">)</span>
    <span class="c1"># Identify those segments above threshold</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">reference_mean</span> <span class="o">&gt;</span> <span class="n">threshold_db</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Number of segments above threshold</span>

    <span class="c1"># Exit if not enough segments above zero</span>
    <span class="k">if</span> <span class="n">nseg</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Function AveCovary2: Ave signal below threshold, outputs set to 0.&quot;</span>
        <span class="p">)</span>
        <span class="n">average_covariance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># syncov = 0</span>
        <span class="n">ihc_sync_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">average_covariance</span><span class="p">,</span> <span class="n">ihc_sync_covariance</span>

    <span class="c1"># Remove the silent segments</span>
    <span class="n">signal_cross_covariance</span> <span class="o">=</span> <span class="n">signal_cross_covariance</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
    <span class="n">signal_rms</span> <span class="o">=</span> <span class="n">signal_rms</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>

    <span class="c1"># Compute the time-frequency weights. The weight=1 if a segment in a</span>
    <span class="c1"># frequency band is above threshold, and weight=0 if below threshold.</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>  <span class="c1"># No IHC synchronization roll-off</span>
    <span class="n">weight</span><span class="p">[</span><span class="n">signal_rms</span> <span class="o">&gt;</span> <span class="n">threshold_db</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># The wsync tensor should be constructed as follows:</span>
    <span class="c1">#</span>
    <span class="c1"># wsync = np.zeros((6, n_channels, nseg))</span>
    <span class="c1"># for k in range(n_channels):</span>
    <span class="c1">#    for n in range(nseg):</span>
    <span class="c1">#        # Thresh in dB SL for including time-freq tile</span>
    <span class="c1">#        if signal_rms[k, n] &gt; threshold_db:</span>
    <span class="c1">#            wsync[:, k, n] = fsync[:, k]</span>
    <span class="c1">#</span>
    <span class="c1"># This can be written is an efficient vectorsized form as follows:</span>
    <span class="n">wsync</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">signal_rms</span> <span class="o">&gt;</span> <span class="n">threshold_db</span>
    <span class="n">fsync3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">fsync</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">nseg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">wsync</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsync3d</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>

    <span class="c1"># Sum the weighted covariance values</span>
    <span class="c1"># Sum of weighted time-freq tiles</span>
    <span class="n">csum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">signal_cross_covariance</span><span class="p">))</span>

    <span class="n">wsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span>  <span class="c1"># Total number of tiles above threshold</span>

    <span class="n">tiles_above_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

    <span class="c1"># Sum of weighted time-freq tiles</span>
    <span class="n">sum_weighted_time_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wsync</span> <span class="o">*</span> <span class="n">signal_cross_covariance</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">tiles_above_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wsync</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Exit if not enough segments above zero</span>
    <span class="k">if</span> <span class="n">wsum</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">average_covariance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Function AveCovary2: Signal tiles below threshold, outputs set to 0.&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">average_covariance</span> <span class="o">=</span> <span class="n">csum</span> <span class="o">/</span> <span class="n">wsum</span>
    <span class="n">ihc_sync_covariance</span> <span class="o">=</span> <span class="n">sum_weighted_time_freq</span> <span class="o">/</span> <span class="n">tiles_above_threshold</span>

    <span class="k">return</span> <span class="n">average_covariance</span><span class="p">,</span> <span class="n">ihc_sync_covariance</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Project name not set</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../recipes_doc.html">Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CONTRIBUTING.html">Contributing to pyClarity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../CODE_OF_CONDUCT.html">Contributor Covenant Code of Conduct</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../clarity.html">clarity package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../recipes.html">recipes package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>